Class P_EventHandler : StaticEventHandler
{
	double effectTimer;
	double timer;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	P_EventList list;
	Array<P_Event> activeEffects;
	
	Array<String> criticals;
	
	double prevForwardMove1;
	double prevForwardMove2;
	double prevSideMove1;
	double prevSideMove2;
	
	int timelimit;

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		list = P_EventList.create();
		console.printf('Loading in ' .. E_NumEvents .. ' events!');
		
		timer = 0;
		
		activeEffects.clear();
		criticals.clear();
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		if (activeEffects.size())
		{
			for (int i = 0; i < activeEffects.size(); ++i)
			{
				P_Event event = activeEffects[i];
				if (event.type == E_PerLevel || event.type == E_Instant)
				{
					removeEffect(event);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		++timer;
		timelimit = list.timelimit();
		if (list.timeLimit() - timer <= 0)
		{
			timer = 0;
			
			addEffectToActive();
		}
		
		for (int i = 0; i < activeEffects.size(); ++i)
		{
			if (!activeEffects[i].activated) activeEffects[i].eventFunc();
			if (activeEffects[i].type == E_Instant) activeEffects[i].activated = true;
			activeEffects[i].life += 1;
			if (activeEffects[i].life > activeEffects[i].duration && activeEffects[i].type != E_PerLevel)
			{
				removeEffect(activeEffects[i]);
			}
		}
	}
	
	void addEffectToActive()
	{
		P_Event effect = list.getEffect();
		activeEffects.push(effect);
	}
	
	void removeEffect(P_Event _effect)
	{
		P_Event effect = _effect;
		int place = activeEffects.find(effect);
		activeEffects.delete(place);
		activeEffects.shrinkToFit();
		effect.closeFunc();
		effect.destroy();
	}
	
	override void RenderOverlay(RenderEvent event)
	{
		double ratio = timer / timeLimit;
		double width = ratio * double(Screen.getWidth());
		Screen.DrawThickLine(0, 5, width, 5, 20, Color("00CC00"));
		
		if (activeEffects.size() > 0)
		{
			int yOffset = 150;
			for (int i = 0; i < activeEffects.size(); ++i)
			{
				P_Event effect = activeEffects[i];
				if (activeEffects[i].type == E_Timed)
				{
					double ratio = 1 - (double(effect.life) / double(effect.duration));
					Screen.DrawThickLine(20, yOffset, 20 + (200 * ratio), yOffset, 10, color("FF0000"));
				}
				Screen.DrawText(BIGFONT, Font.CR_White, 20, (yoffset - 20), effect.eventname);
				yOffset += 30;
			}
		}
	}
	
	int sectorIndex;
	Vector2 sectorCenter;
	Vector3 tempPos;
	Actor actorPointer;
	
	override void NetworkProcess(ConsoleEvent event)
	{
		infoplayer = players[event.Player];
		player = infoplayer.mo;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		Array<string> command;
		event.name.Split (command, ":");
		
		switch (name(command[0]))
		{
			case 'meta':
				switch (name(command[1]))
				{
					case 'speedup':
						list.timemodifier /= command[2].toDouble();
						break;
					case 'slowdown':
						list.timemodifier *= command[2].toDouble();
						break;
				}
				break;
			default:
				console.printf('Fix me! ' .. event.name);
		}
	}
}