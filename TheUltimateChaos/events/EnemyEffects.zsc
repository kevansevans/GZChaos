Class TUC_AllMonstersWakeUp : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.target = player;
				mo.lastheard = player;
				mo.bAmbush = false;
			}
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_AllMonstersWakeUp');
		event.eventname = "All monsters wake up";
		event.duration = 35 * 60;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_ArachnotronGrowthSpurt : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "Arachnotron" && mo.health > 0)
			{
				let momma = Actor.spawn("SpiderMastermind", mo.pos);
				momma.health = mo.health;
				momma.bMap07Boss2 = true;
				mo.destroy();
			}
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_ArachnotronGrowthSpurt');
		event.eventname = "Arachnotron Growth Spurt";
		event.duration = 35 * 60;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_CacodemonHitscanners : TUC_Event
{

	override void spawnFunc(Actor mo)
	{
		if (mo is "CacodemonBall")
		{
			let owner = mo.target;
			
			owner.A_FaceTarget();
			owner.A_CustomBulletAttack(22.5, 0, 3, random(1,5) * 3, "BulletPuff", 0, CBAF_NORANDOM);
			owner.A_StartSound("shotguy/attack", CHAN_WEAPON);
			
			mo.Destroy();
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_CacodemonHitscanners');
		event.eventname = "Shotgun Cacodemons";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_FrictionlessEnemies : TUC_Event
{
	Array<Actor> pre;

	override void eventFunc()
	{
		if (!pre.size()) pre.clear();
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				if (mo.bNoFriction)
				{
					pre.push(mo);
					continue;
				}
			
				mo.bNoFriction = true;
				mo.bPushable = true;
				mo.bSlidesOnWalls = true;
			}	
		}
	}
		
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				if (pre.find(mo) == pre.size()) continue;
				mo.bNoFriction = false;
				mo.bPushable = false;
				mo.bSlidesOnWalls = false;
			}
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FrictionlessEnemies');
		event.eventname = "Enemies have no friction";
		event.duration = (35 * 60 * 2) + (35 * 30);
		event.type = E_Timed;
		return event;
	}
}

Class TUC_AnkleBiterEnemies : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.scale.x /= 3;
				mo.scale.y /= 3;
				mo.A_SetSize(mo.height / 3, mo.radius / 3, false);
			}
		}
		
		activated = true;
	}
	
	override void closeFunc() 
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.scale.x = 1;
				mo.scale.y = 1;
				mo.A_SetSize(mo.height * 3, mo.radius * 3, false);
			}
		}
	}

	static TUC_Event create()
	{
		TUC_Event event = new('TUC_AnkleBiterEnemies');
		event.eventname = "Ankle Biters";
		event.duration = 35 * 60 * 2;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_SpawnFriendlyGreatGodImp : TUC_Event
{
	override void eventFunc()
	{
		while (true)
		{
			int rng = random(0, level.Sectors.size() - 1);
			let c = level.Sectors[rng].centerspot;
			if (level.IsPointInLevel((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c))))
			{
				double ceilheight = level.Sectors[rng].ceilingplane.ZAtPoint(c);
				double floorheight = level.Sectors[rng].floorplane.ZAtPoint(c);
				if (ceilheight - floorheight > 64)
				{
					let friend = Actor.spawn('greatgodimp', (c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c)));
					friend.bFriendly = true;
					friend.bIsMonster = false;
					activated = true;
					break;
				}
			}
		}
	}
	
	override void closeFunc() 
	{
		
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_SpawnFriendlyGreatGodImp');
		event.eventname = "Thou hast been blessed!";
		event.duration = 35 * 90;
		event.type = E_PerLevel;
		return event;
	}
}

Class TUC_StatueEnemies : TUC_Event
{
	Array<Actor> pushables;
	Array<Actor> inactive;
	
	bool set;

	override void eventFunc()
	{
		if (!set)
		{
			pushables.clear();
			inactive.clear();
			set = true;
		}
	
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				if (mo.bPushable) pushables.push(mo);
				if (mo.bDormant) inactive.push(mo);
				mo.bPushable = true;
				mo.bShootable = false;
				mo.tics = -1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bPushable = false;
				mo.bShootable = true;
				mo.tics = 1;
			}
		}
		
		for (int i = 0; i < pushables.size(); ++i)
		{
			if (!pushables[i]) continue;
			pushables[i].bPushable = true;
		}
		
		for (int j = 0; j < inactive.size(); ++j)
		{
			if(!inactive[j]) continue;
			inactive[j].bDormant = true;
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = false;
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_StatueEnemies');
		event.eventname = "Statue enemies";
		event.duration = 35 * 30;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_NightmareMonsters : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster && !mo.bStealth)
			{
				mo.bStealth = true;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bStealth = false;
			}
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_NightmareMonsters');
		event.eventname = "Stealth Monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_NightmareRespawns : TUC_Event
{
	array<actor> preRespawn;
	bool set;
	
	override void eventFunc()
	{
		if (!set)
		{
			preRespawn.clear();
			set = true;
		}
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				if (mo.bAlwaysRespawn) preRespawn.push(mo);
				else mo.bAlwaysRespawn = true;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bAlwaysRespawn = false;
			}
		}
		
		for (int i = 0; i < preRespawn.size(); ++i)
		{
			if (!preRespawn[i]) continue;
			preRespawn[i].bAlwaysRespawn = true;
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_NightmareRespawns');
		event.eventname = "Respawning monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_SpawnGreatGodImp : TUC_Event
{
	Actor impy;

	override void eventFunc()
	{
		while (true)
		{
			int rng = random(0, level.Sectors.size() - 1);
			let c = level.Sectors[rng].centerspot;
			if (level.IsPointInLevel((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c))))
			{
				double ceilheight = level.Sectors[rng].ceilingplane.ZAtPoint(c);
				double floorheight = level.Sectors[rng].floorplane.ZAtPoint(c);
				if (ceilheight - floorheight > 64)
				{
					impy = Actor.spawn('greatgodimp', (c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c)));
					activated = true;
					break;
				}
			}
		}
	}
	
	override void closeFunc() 
	{
		if (impy) impy.destroy();
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_SpawnGreatGodImp');
		event.eventname = "The Great God Imp";
		event.duration = 35 * 60;
		event.type = E_Timed;
		return event;
	}
}