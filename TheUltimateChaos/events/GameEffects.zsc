Class TUC_SeekerProjectiles : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				mo.bSeekerMissile = true;
				mo.tracer = player;
				mo.A_Tracer();
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				
				mo.bSeekerMissile = false;
			}
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_SeekerProjectiles');
		event.eventname = "All projectiles seek player";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_OUCH : TUC_EVENT
{
	bool set;

	//This code is borrowed from Marisa Kirasame's OUCH_M mod
	override void eventFunc()
	{
		if (!set)
		{
			int i;
			TextureID thetex;
			Line l;
			Sector s;
			thetex = TexMan.CheckForTexture("STFOUCH0",TexMan.Type_Any);
			if ( thetex.IsNull() || !thetex.IsValid() ) return; // no texture available
			int j, k;
			for ( i=0; i<level.Lines.Size(); i++ )
			{
				l = level.Lines[i];
				for ( j=0; j<3; j++ ) for ( k=0; k<2; k++ ) if ( l.sidedef[k] && !l.sidedef[k].GetTexture(j).IsNull() && (l.sidedef[k].GetTexture(j) != skyflatnum) ) l.sidedef[k].SetTexture(j,thetex);
			}
			for ( i=0; i<level.Sectors.Size(); i++ )
			{
				s = level.Sectors[i];
				for ( j=0; j<2; j++ ) if ( !level.Sectors[i].GetTexture(j).IsNull() && (level.Sectors[i].GetTexture(j) != skyflatnum) ) level.Sectors[i].SetTexture(j,thetex);
				s.flags |= Sector.SECF_FRICTION;
			}
			thetex = TexMan.CheckForTexture("OUCHSKY",TexMan.Type_Any);
			level.ChangeSky(thetex,thetex);
			set = true;
		}
	
		Line l;
		Sector s;
		int i, j;
		for ( i=0; i<level.Lines.Size(); i++ )
		{
			l = level.Lines[i];
			for ( j=0; j<3; j++ )
			{
				l.sidedef[0].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
				l.sidedef[0].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				if ( level.Lines[i].sidedef[1] )
				{
					l.sidedef[1].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
					l.sidedef[1].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				}
			}
		}
		int echochance = Random[Ouch](0,10);
		for ( i=0; i<level.Sectors.Size(); i++ )
		{
			s = level.Sectors[i];
			for ( j=0; j<2; j++ )
			{
				s.SetXOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetYOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetXScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetYScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetAngle(j,FRandom[Ouch](0.0,360.0));
				s.SetColor(Color(Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255)),0);
			}
			if ( gametic % 3 ) continue;
			if ( echochance < 3 ) s.SetEnvironmentID(65535);
			else s.SetEnvironmentID(0);
			s.friction = FRandom[Ouch](0.9,1.1);
		}
		
		ThinkerIterator aa = ThinkerIterator.Create("Actor");
		Actor a;
		while ( a = Actor(aa.Next()) )
		{
			if ( a.sprite == a.GetSpriteIndex('OUCH') ) continue; // abort_m ouch faces are unaffected by this
			if ( a is "OuchMFace" ) continue; // ouch faces do their own thing
			if ( !(gametic%3) && (Random[Ouch](0,10) < 3)) a.A_StartSound("ouch/dspdiehi",CHAN_5, 0, FRandom[Ouch](0.05,0.3));
			if ( a.player && (!a.player.ReadyWeapon || (a.player.ReadyWeapon.GetClassName() != "OuchWeapon")) ) // ouch weapon is unaffected too
			{
				for ( PSprite psp=a.player.psprites; psp; psp=psp.next )
				{
					if ( psp.sprite == a.GetSpriteIndex('TNT1') ) continue;
					psp.sprite = a.GetSpriteIndex('OUCF');
					psp.frame = 1;
				}
			}
			if ( a.sprite != a.GetSpriteIndex('TNT1') )
			{
				Vector2 base = (1.0,1.0);

				// view-dependant, but who cares, it shouldn't desync
				base = TexMan.GetScaledSize(a.CurState.GetSpriteTexture(int(a.spriteRotation)));
				base.x /= 24.0;
				base.y /= 31.0;
				Vector2 defscale = GetDefaultByType(a.GetClass()).scale;
				base.x *= defscale.x;
				base.y *= defscale.y;
				a.sprite = a.GetSpriteIndex('OUCF');
				a.frame = 0;
				// helpers so you can tell what is what
				if ( a.bISMONSTER ) a.A_SetTranslation('OuchEnemy');
				else if ( a is 'RedCard' || a is 'RedSkull' ) a.A_SetTranslation('OuchRedKey');
				else if ( a is 'BlueCard' || a is 'BlueSkull' ) a.A_SetTranslation('OuchBlueKey');
				else if ( a is 'YellowCard' || a is 'YellowSkull' ) a.A_SetTranslation('OuchYellowKey');
				else if ( a is 'Ammo' || a is 'Weapon' ) a.A_SetTranslation('OuchAmmo');
				else if ( a is 'Health' ) a.A_SetTranslation('OuchHealth');
				else if ( a is 'Armor' ) a.A_SetTranslation('OuchArmor');
				else if ( a is 'Inventory' ) a.A_SetTranslation('OuchMiscItem');
				else a.A_SetTranslation('OuchOther');
				
				a.A_SetScale(base.x*FRandom[Ouch](0.8,1.2),base.y*FRandom[Ouch](0.8,1.2));
			}
			if ( (a.sprite == a.GetSpriteIndex('TNT1')) || a.bNOSECTOR || a.bNOCLIP || a.bINVISIBLE ) continue; // prevent breakage of some things
			if (!(a is "PlayerPawn"))
			{
				if ( !(gametic%10)) a.A_ChangeVelocity(a.vel.x+FRandom[Ouch](-1.0,1.0),a.vel.y+FRandom[Ouch](-1.0,1.0),a.vel.z+FRandom[Ouch](-10.0,10.0));
			}
		}
	}
	
	override void closeFunc()
	{
	
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_OUCH');
		event.eventname = "OUCH";
		event.duration = 35 * 60 * 9999;
		event.type = E_PerLevel;
		return event;
	}
}

Class TUC_FakeLagCrash : TUC_Event
{
	override void eventFunc()
	{
		string music = level.music;
		
		let player = players[consoleplayer].mo;
		player.S_ChangeMusic("");
	
							//50 Million
		for (int i = 0; i < 50000000; ++i)
		{
			let thingy = TUC_FakeLagCrash.create();
			thingy.destroy();
		}
		
		player.S_ChangeMusic(music);
		
		activated = true;
	}
	
	override void closeFunc()
	{
	
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FakeLagCrash');
		event.eventname = "Fake crash";
		event.duration = 35 * 30;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_RestartLevel : TUC_Event
{
	bool restart;

	override void eventFunc()
	{
		restart = true;
		if (life == duration - 1)
		{
			int rng = random(1, 5);
			if (rng != 3)
			{
				type = E_HiddenTimer;
				life = 0;
				duration = 35 * 15;
				eventname = "Fake level restart";
				restart = false;
				activated = true;
			}
		}
	}
	
	override void closeFunc()
	{
		if (restart)
		{
			level.changeLevel(level.mapname);
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_RestartLevel');
		event.eventname = "Exit and restart level";
		event.duration = 35 * 10;
		event.type = E_Timed;
		return event;
	}
}