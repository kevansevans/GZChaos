Class TUC_JupiterGravity : TUC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			if (event is "TUC_MoonGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(10);
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_JupiterGravity');
		event.eventname = "Jupiter Gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_MoonGravity : TUC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			if (event is "TUC_JupiterGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_LowGravity();
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_MoonGravity');
		event.eventname = "Moon Gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_FartingMonsters : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster && mo.health > 0)
			{
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % 35 == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FartingMonsters');
		event.eventname = "Farting Monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_FartingItems : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "inventory")
			{
				if (Inventory(mo).owner) continue;
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % 35 == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FartingItems');
		event.eventname = "Hoping mad items";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_FartingPlayer : TUC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		double zfloor = player.getZAt();
		if (zfloor != player.pos.z) return;
		if ((gametic + random(0, 35)) % 35 == 0)
		{
			if (!random(0, 5)) return;
		
			double angle = random(0, 359);
			Double xspeed = cos(angle) * 5;
			Double yspeed = sin(angle) * 5;
			
			player.vel.x = xspeed;
			player.vel.y = yspeed;
			player.vel.z = 15 + random(-5, 5);
			
			player.A_StartSound("poot/poot", CHAN_AUTO);
		}
	}
	
	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FartingPlayer');
		event.eventname = "Farting player";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_FastProjectiles : TUC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(1.5);
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FastProjectiles');
		event.eventname = "Fast projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}


Class TUC_SlowProjectiles : TUC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.5);
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_SlowProjectiles');
		event.eventname = "Slow projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class TUC_ExtraSlowProjectiles : TUC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.25);
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_ExtraSlowProjectiles');
		event.eventname = "Slower projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class TUC_PainfullySlowProjectiles : TUC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.01);
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_PainfullySlowProjectiles');
		event.eventname = "Painfully Slow projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class TUC_DisableGravity : TUC_Event
{
	bool set;
	
	Array<Actor> flying;

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerInfo infoplayer = players[consoleplayer];
		PlayerPawn player = infoplayer.mo;
		
		infoplayer.cheats |= CF_FLY;
		player.bFly = true;
		
		while (mo = Actor(it.next()))
		{
			if (!(mo is "playerPawn")) mo.A_SetGravity(0.0);
			if (!set) {
				mo.vel.z = FRandom(0.1, 0.9);
				if (mo.bIsMonster)
				{
					if (mo.bFloat) mo.giveInventory('TUC_CanAlreadyFly', 1);
					mo.bFloat = true;
					mo.bNoGravity = true;
				}
			}
		}
		
		set = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerInfo infoplayer = players[consoleplayer];
		PlayerPawn player = infoplayer.mo;
		
		infoplayer.cheats &= ~(CF_FLY);
		player.bFly = false;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
			if (!mo.countInv('TUC_CanAlreadyFly'))
			{
				mo.bFloat = false;
				mo.bNoGravity = false;
			}
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_DisableGravity');
		event.eventname = "Everything ignores gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_CanAlreadyFly : Inventory {}

Class TUC_ExplodingBulletPuffs : TUC_Event
{
	override void spawnFunc(Actor mo)
	{
		if (mo is "BulletPuff")
		{
			mo.A_Explode(32, 128, 0);
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_ExplodingBulletPuffs');
		event.eventname = "All bullet puffs explode";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_SeekerProjectiles : TUC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				mo.bSeekerMissile = true;
				mo.tracer = player;
				mo.A_Tracer();
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				
				mo.bSeekerMissile = false;
			}
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_SeekerProjectiles');
		event.eventname = "All projectiles seek player";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_OUCH : TUC_EVENT
{
	bool set;

	//This code is borrowed from Marisa Kirasame's OUCH_M mod
	override void eventFunc()
	{
		if (!set)
		{
			int i;
			TextureID thetex;
			Line l;
			Sector s;
			thetex = TexMan.CheckForTexture("STFOUCH0",TexMan.Type_Any);
			if ( thetex.IsNull() || !thetex.IsValid() ) return; // no texture available
			int j, k;
			for ( i=0; i<level.Lines.Size(); i++ )
			{
				l = level.Lines[i];
				for ( j=0; j<3; j++ ) for ( k=0; k<2; k++ ) if ( l.sidedef[k] && !l.sidedef[k].GetTexture(j).IsNull() && (l.sidedef[k].GetTexture(j) != skyflatnum) ) l.sidedef[k].SetTexture(j,thetex);
			}
			for ( i=0; i<level.Sectors.Size(); i++ )
			{
				s = level.Sectors[i];
				for ( j=0; j<2; j++ ) if ( !level.Sectors[i].GetTexture(j).IsNull() && (level.Sectors[i].GetTexture(j) != skyflatnum) ) level.Sectors[i].SetTexture(j,thetex);
				s.flags |= Sector.SECF_FRICTION;
			}
			thetex = TexMan.CheckForTexture("OUCHSKY",TexMan.Type_Any);
			level.ChangeSky(thetex,thetex);
			set = true;
		}
	
		Line l;
		Sector s;
		int i, j;
		for ( i=0; i<level.Lines.Size(); i++ )
		{
			l = level.Lines[i];
			for ( j=0; j<3; j++ )
			{
				l.sidedef[0].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
				l.sidedef[0].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				if ( level.Lines[i].sidedef[1] )
				{
					l.sidedef[1].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
					l.sidedef[1].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				}
			}
		}
		int echochance = Random[Ouch](0,10);
		for ( i=0; i<level.Sectors.Size(); i++ )
		{
			s = level.Sectors[i];
			for ( j=0; j<2; j++ )
			{
				s.SetXOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetYOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetXScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetYScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetAngle(j,FRandom[Ouch](0.0,360.0));
				s.SetColor(Color(Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255)),0);
			}
			if ( gametic % 3 ) continue;
			if ( echochance < 3 ) s.SetEnvironmentID(65535);
			else s.SetEnvironmentID(0);
			s.friction = FRandom[Ouch](0.9,1.1);
		}
		
		ThinkerIterator aa = ThinkerIterator.Create("Actor");
		Actor a;
		while ( a = Actor(aa.Next()) )
		{
			if ( a.sprite == a.GetSpriteIndex('OUCH') ) continue; // abort_m ouch faces are unaffected by this
			if ( a is "OuchMFace" ) continue; // ouch faces do their own thing
			if ( !(gametic%3) && (Random[Ouch](0,10) < 3)) a.A_StartSound("ouch/dspdiehi",CHAN_5, 0, FRandom[Ouch](0.05,0.3));
			if ( a.player && (!a.player.ReadyWeapon || (a.player.ReadyWeapon.GetClassName() != "OuchWeapon")) ) // ouch weapon is unaffected too
			{
				for ( PSprite psp=a.player.psprites; psp; psp=psp.next )
				{
					if ( psp.sprite == a.GetSpriteIndex('TNT1') ) continue;
					psp.sprite = a.GetSpriteIndex('OUCF');
					psp.frame = 1;
				}
			}
			if ( a.sprite != a.GetSpriteIndex('TNT1') )
			{
				Vector2 base = (1.0,1.0);

				// view-dependant, but who cares, it shouldn't desync
				base = TexMan.GetScaledSize(a.CurState.GetSpriteTexture(int(a.spriteRotation)));
				base.x /= 24.0;
				base.y /= 31.0;
				Vector2 defscale = GetDefaultByType(a.GetClass()).scale;
				base.x *= defscale.x;
				base.y *= defscale.y;
				a.sprite = a.GetSpriteIndex('OUCF');
				a.frame = 0;
				// helpers so you can tell what is what
				if ( a.bISMONSTER ) a.A_SetTranslation('OuchEnemy');
				else if ( a is 'RedCard' || a is 'RedSkull' ) a.A_SetTranslation('OuchRedKey');
				else if ( a is 'BlueCard' || a is 'BlueSkull' ) a.A_SetTranslation('OuchBlueKey');
				else if ( a is 'YellowCard' || a is 'YellowSkull' ) a.A_SetTranslation('OuchYellowKey');
				else if ( a is 'Ammo' || a is 'Weapon' ) a.A_SetTranslation('OuchAmmo');
				else if ( a is 'Health' ) a.A_SetTranslation('OuchHealth');
				else if ( a is 'Armor' ) a.A_SetTranslation('OuchArmor');
				else if ( a is 'Inventory' ) a.A_SetTranslation('OuchMiscItem');
				else a.A_SetTranslation('OuchOther');
				
				a.A_SetScale(base.x*FRandom[Ouch](0.8,1.2),base.y*FRandom[Ouch](0.8,1.2));
			}
			if ( (a.sprite == a.GetSpriteIndex('TNT1')) || a.bNOSECTOR || a.bNOCLIP || a.bINVISIBLE ) continue; // prevent breakage of some things
			if (!(a is "PlayerPawn"))
			{
				if ( !(gametic%10)) a.A_ChangeVelocity(a.vel.x+FRandom[Ouch](-1.0,1.0),a.vel.y+FRandom[Ouch](-1.0,1.0),a.vel.z+FRandom[Ouch](-10.0,10.0));
			}
		}
	}
	
	override void closeFunc()
	{
	
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_OUCH');
		event.eventname = "OUCH";
		event.duration = 35 * 60 * 9999;
		event.type = E_PerLevel;
		return event;
	}
}

Class TUC_FakeLagCrash : TUC_Event
{
	int spawn;
	int delay;

	override void eventFunc()
	{
		if (life > delay)
		{
			string music = level.music;
			
			let player = players[consoleplayer].mo;
			player.S_ChangeMusic("");
			
							//50 Million
			for (int i = 0; i < 50000000; ++i)
			{
				let thingy = TUC_FakeLagCrash.create();
				thingy.destroy();
			}
		
			player.S_ChangeMusic(music);
		
			eventname = "Fake crash";
			activated = true;
		}
	}
	
	override void closeFunc()
	{
	
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_FakeLagCrash');
		TUC_FakeLagCrash(event).spawn = gametic;
		TUC_FakeLagCrash(event).delay = 35 * random(5, 10);
		event.eventname = "Nothing.";
		event.duration = 35 * 60;
		event.type = E_HiddenTimer;
		return event;
	}
}

Class TUC_RestartLevel : TUC_Event
{
	bool restart;

	override void eventFunc()
	{
		restart = true;
		if (life == duration - 1)
		{
			int rng = random(1, 5);
			if (rng != 3)
			{
				type = E_HiddenTimer;
				life = 0;
				duration = 35 * 15;
				eventname = "Fake level restart";
				restart = false;
				activated = true;
			}
		}
	}
	
	override void closeFunc()
	{
		if (restart)
		{
			level.changeLevel(level.mapname);
		}
	}

	Static TUC_Event create()
	{
		TUC_Event event = new('TUC_RestartLevel');
		event.eventname = "Exit and restart level";
		event.duration = 35 * 10;
		event.type = E_Timed;
		return event;
	}
}