Class TUC_DiscoSkybox : TUC_Event
{
	TextureID originalSky;
	Array<String> textures;
	int interval;
	override void eventFunc()
	{
		if (!originalSky) {
		
			originalSky = level.skytexture1;
			textures.clear();
			
			interval = random(1, 10);
		
			for (int i = 0; i < Wads.getNumLumps(); ++i)
			{
				TextureID _locTexture = TexMan.checkForTexture(Wads.getLumpName(i));
				String texturename = TexMan.getName(_locTexture);
				
				if (texturename)
				{
					textures.push(texturename);
				}
			}
		}
		
		if (gametic % interval == 0)
		{
			interval = random(1, 10);
			int index = random(0, textures.size() - 1);
			level.changeSky(TexMan.checkForTexture(textures[index]), TexMan.checkForTexture(''));
		}
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_DiscoSkybox');
		event.eventname = "Disco Skybox";
		event.duration = 35 * 60;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_SuperSecretsEverywhere : TUC_Event
{
	override void eventFunc()
	{
		for (int i = 0; i < level.sectors.size(); ++i)
		{
			sector sec = level.sectors[i];
			sec.flags |= Sector.SECF_SECRET;
		}
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo is "Inventory")
			{
				mo.bCountSecret = true;
			}
			
		}
	}
	
	override void closeFunc()
	{}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_SuperSecretsEverywhere');
		event.eventname = "Everything is a secret";
		event.duration = 35 * 60;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_IncreasedSectorFriction : TUC_Event
{
	Array<Sector> applied;
	int factor;
	
	override void eventFunc()
	{
		if (!applied.size()) 
		{
			applied.clear();
			factor = random(2, 10);
			eventname = factor .. "x sector friction";
		}
		
		for (int i = 0; i < level.sectors.size(); ++i)
		{
			sector sec = level.sectors[i];
			
			if (applied.size() == 0 || applied.find(sec) == applied.size())
			{
				sec.friction /= factor;
				sec.flags |= Sector.SECF_FRICTION;
				applied.push(sec);
			}
		}
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < applied.size(); ++i)
		{
			if (!applied[i]) continue;
			
			sector sec = applied[i];
			
			sec.friction *= factor;
			sec.flags &= ~(Sector.SECF_FRICTION);
		}
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_IncreasedSectorFriction');
		event.eventname = "Increased Sector Friction";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

/*Class TUC_TheVomitorium : TUC_Event
{
	Array<line> lines;

	override void eventFunc()
	{
		lines.clear();
		
		PlayerPawn player = players[consoleplayer].mo;
		
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			
			if (linedef.special != 0)
			{
				lines.push(linedef);
				continue;
			}
			
			scroll_wall(0, random(-16,16),random(-16,16),0,7);
			
		}
		
		activated = true;
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			if (lines.find(linedef) != lines.size())
			{
				linedef.special = 0;
				linedef.args[0] = 0;
				linedef.args[1] = 0;
				linedef.args[2] = 0;
				linedef.args[3] = 0;
				linedef.args[4] = 0;
			}
		}
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_TheVomitorium');
		event.eventname = "The Vomitorium";
		event.duration = 35 * 60;
		event.type = E_Timed;
		return event;
	}
}*/

Class TUC_ClearAutoMap : TUC_Event
{
	override void eventFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			level.lines[i].flags &= ~(Line.ML_MAPPED);
		}
	}
	
	override void closeFunc()
	{
	
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_ClearAutoMap');
		event.eventname = "Clear Auto Map";
		event.duration = 35 * 30;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_BrokenBSPRendering : TUC_Event
{
	Array<line> lines;

	override void eventFunc()
	{
		
		if (!lines.size())
		{
			lines.clear();
			for (int i = 0; i < level.lines.size(); ++i)
			{
				line linedef = level.lines[i];
				if (linedef.flags & line.ML_TWOSIDED)
				{
					linedef.flags &= ~(line.ML_TWOSIDED);
					continue;
				}
				else lines.push(linedef);
			}
		}
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			if (lines.find(linedef) == lines.size())
			{
				linedef.flags |= line.ML_TWOSIDED;
			}
		}
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_BrokenBSPRendering');
		event.eventname = "BSP Corruption";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_TheFloorIsLava : TUC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("LAVA1"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 20;
	}
	
	override void closeFunc()
	{
	
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_TheFloorIsLava');
		event.eventname = "The floor is lava!";
		event.duration = 35 * 10;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_TheFloorIsNukage : TUC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("NUKAGE1"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 10;
	}
	
	override void closeFunc()
	{
	
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_TheFloorIsNukage');
		event.eventname = "The floor is Nukage!";
		event.duration = 35 * 10;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_TheFloorIsSludge : TUC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("SLIME01"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 5;
	}
	
	override void closeFunc()
	{
	
	}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_TheFloorIsSludge');
		event.eventname = "The floor is sludge!";
		event.duration = 35 * 10;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_SetAllWallsToStartan : TUC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			if (event is "TUC_SetAllWallsToFireblu") return false;
			if (event is "TUC_OUCH") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		TextureID walltex = TexMan.checkForTexture("STARTAN2");
	
		level.ChangeSky(TexMan.checkForTexture("SKY1"), TexMan.checkForTexture(''));
	
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
			
			sidedef.linedef.flags &= ~(Line.ML_DONTPEGTOP | Line.ML_DONTPEGBOTTOM);
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID curtex = sidedef.GetTexture(wall);
				if (curtex)
				{
					string wallname = TexMan.getName(curtex);
					
					if (wallname != "DOORTRAK" && !checkIfReplaceable(wallname)) continue;
					sidedef.setTexture(wall, walltex);
				}
			}
		}
		
		TextureID floortex = TexMan.CheckForTexture("FLOOR0_1");
		TextureID ceiltex = TexMan.CheckForTexture("CEIL1_1");
		
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			string orgFloorText = TexMan.getName(level.sectors[se].getTexture(0));
			if (orgFloorText != "F_SKY1" && checkIfReplaceable(orgFloorText))
			{
				level.sectors[se].setTexture(0, floortex);
			}
			string orgCeilText = TexMan.getName(level.sectors[se].getTexture(1));
			if (orgCeilText != "F_SKY1" && checkIfReplaceable(orgCeilText))
			{
				level.sectors[se].setTexture(1, ceiltex);
			}
			level.sectors[se].lightlevel = 192;
		}
		activated = true;
	}
	
	override void closeFunc()
	{
	
	}

	static TUC_Event create()
	{
		TUC_Event event = new('TUC_SetAllWallsToStartan');
		event.eventname = "MyFirstMap.wad";
		event.duration = 35 * 60 * 99999;
		event.deleteme = true;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_SetAllWallsToFireblu : TUC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			if (event is "TUC_SetAllWallsToStartan") return false;
			if (event is "TUC_OUCH") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		TextureID newtex = TexMan.checkForTexture("FIREBLU1");
		
		level.ChangeSky(newtex, TexMan.checkForTexture(''));
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, newtex);
				}
			}
		}
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				level.sectors[se].setTexture(0, newtex);
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				level.sectors[se].setTexture(1, newtex);
			}
			level.sectors[se].lightlevel = 192;
		}
		
		activated = true;
	}
	
	override void closeFunc()
	{
	
	}

	static TUC_Event create()
	{
		TUC_Event event = new('TUC_SetAllWallsToFireblu');
		event.eventname = "Everyone's favorite texture";
		event.duration = 35 * 60 * 99999;
		event.deleteme = true;
		event.type = E_Instant;
		return event;
	}
}

Class TUC_ShuffleKeyTextures : TUC_Event
{
	override void eventFunc()
	{
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
	
			for (int wall = 0; wall < 3; ++wall)
			{
				int rng = random(0, 1);
				if (rng == 1) continue;
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					string texname = TexMan.getName(walltex);
					texname.truncate(4);
					if (texname != "DOOR") continue;
					else
					{
						switch (name(TexMan.getName(walltex)))
						{
							case 'DOORBLU':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORRED2'));
								if (random(1, 10) != 10) break;
							case 'DOORRED2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORYEL'));
								if (random(1, 10) != 10) break;
							case 'DOORYEL':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORBLU2'));
								if (random(1, 10) != 10) break;
							case 'DOORBLU2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORRED'));
								if (random(1, 10) != 10) break;
							case 'DOORRED':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORYEL2'));
								if (random(1, 10) != 10) break;
							case 'DOORYEL2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORBLU'));
								break;
						}
					}
				}
			}
		}
	}
	
	override void closeFunc()
	{
	
	}

	static TUC_Event create()
	{
		TUC_Event event = new('TUC_ShuffleKeyTextures');
		event.eventname = "Shuffle key color textures";
		event.duration = 35 * 5;
		event.type = E_Timed;
		return event;
	}
}

Class TUC_MisalignAllTextures : TUC_Event
{
	override void eventFunc()
	{
		int odds = random(1, 10);
		double amount = (double(odds) / 10) * 100;
		eventname = "I forgot to align " .. int(amount) .. "% of my textures";
		
		for (int i = 0; i < level.sides.size(); ++i)
		{
			int rng = random(1, 10);
			if (rng > odds) continue;
			side sidedef = level.sides[i];
			
			for (int j = 0; j < 3; ++j)
			{
				if (sidedef.getTexture(j))
				{
					double x = sidedef.getTextureXOffset(j);
					double y = sidedef.getTextureXOffset(j);
					sidedef.setTextureXOffset(j, x + random(-4, 4));
					sidedef.setTextureYOffset(j, y + random(-4, 4));
				}
			}
		}
		activated = true;
	}
	
	override void closeFunc() {}
	
	static TUC_Event create()
	{
		TUC_Event event = new('TUC_MisalignAllTextures');
		event.eventname = "Misalign textures";
		event.duration = 35 * 30;
		event.type = E_PerLevel;
		return event;
	}
}