Class TUC_EventHandler : StaticEventHandler
{
	double effectTimer;
	double timer;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	TUC_EventList list;
	
	Array<String> criticals;
	
	double prevForwardMove1;
	double prevForwardMove2;
	double prevSideMove1;
	double prevSideMove2;
	
	int timelimit;
	EffectInventory effects;
	
	bool uiIsHidden;
	bool cacoHitscan;

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		list = TUC_EventList.create();
		console.printf('Loading in ' .. (E_NumEvents) .. ' events!');
		
		timer = 0;
		
		criticals.clear();
	}
	
	void getPlayerInfo()
	{
		infoplayer = players[consoleplayer];
		player = infoplayer.mo;
	}
	
	void getEffects()
	{
		if (!player) getPlayerInfo();
		
		if (!player.countInv("EffectInventory"))
		{
			player.giveInventory('EffectInventory', 1);
		}
		
		effects = EffectInventory(player.findInventory("EffectInventory"));
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		uiIsHidden = false;
	
		getPlayerInfo();
		
		getEffects();
	
		if (effects.events.size())
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				TUC_Event event = effects.events[i];
				if (event.type == E_PerLevel || event.type == E_Instant || effects.events[i].deleteme)
				{
					removeEffect(event);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		if (!player) getPlayerInfo();
		
		if (!effects) getEffects();
		
		if (player.health > 0)
		{
			++timer;
		}
		
		timelimit = list.timelimit();
		
		if (list.timeLimit() - timer <= 0)
		{
			timer = 0;
			
			addEffectToActive();
		}
		
		for (inventory item = player.inv; item != null; item = item.inv)
		{	
			if (item is "EffectInventory")
			{
				effects = EffectInventory(item);
				break;
			}
		}
			
		if (player.health > 0)
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				if (player.health > 0)
				{
					if (!effects.events[i].activated) effects.events[i].eventFunc();
					if (effects.events[i].type == E_Instant) effects.events[i].activated = true;
					effects.events[i].life += 1;
					if (effects.events[i].life > effects.events[i].duration && effects.events[i].type != E_PerLevel)
					{
						removeEffect(effects.events[i]);
					}
				}
			}	
		}
	}
	
	override void worldThingSpawned(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			event.spawnFunc(_event.thing);
		}
	}
	
	void addEffectToActive(int _ignore = -1)
	{
		TUC_Event effect = list.getEffect(_ignore);
		effects.events.push(effect);
	}
	
	void removeEffect(TUC_Event _effect)
	{
		TUC_Event effect = _effect;
		effect.closeFunc();
		int place = effects.events.find(effect);
		effects.events.delete(place);
		effects.events.shrinkToFit();
		effect.destroy();
	}
	
	override void RenderUnderlay(RenderEvent event)
	{
		drawScreen();
	}
	
	override void RenderOverlay(RenderEvent event)
	{
		//drawScreen();
	}
	
	ui void drawScreen()
	{
		if (!player) return;
		
		if (!uiIsHidden)
		{
			double ratio = timer / timeLimit;
			double width = ratio * double(Screen.getWidth());
			Screen.DrawThickLine(0, 5, width, 5, 10, Color("00CC00"));
		}
		
		if (!effects) return;
		if (effects.events.size() > 0)
		{
			int yOffset = 150;
			for (int i = 0; i < effects.events.size(); ++i)
			{
				if (uiIsHidden && !(effects.events[i] is "TUC_HideTimerAndEffects")) continue;
			
				TUC_Event effect = effects.events[i];
				Screen.DrawText(BIGFONT, Font.CR_White, 20, (yoffset - 20), effect.eventname, DTA_ScaleX, 1.5, DTA_ScaleY, 1.5);
				if (effects.events[i].type == E_Timed)
				{
					double ratio = 1 - (double(effect.life) / double(effect.duration));
					Screen.DrawThickLine(20, yOffset += 10, 20 + (200 * ratio), yOffset, 10, color("FF0000"), 255);
				}
				yOffset += 60;
			}
		}
	}
	
	override void NetworkProcess(ConsoleEvent event)
	{
		infoplayer = players[event.Player];
		player = infoplayer.mo;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		Array<string> command;
		event.name.Split (command, ":");
		
		switch (name(command[0]))
		{
			case 'meta':
				switch (name(command[1]))
				{
					case 'speedup':
						list.timemodifier /= command[2].toDouble();
						break;
					case 'slowdown':
						list.timemodifier *= command[2].toDouble();
						break;
					case 'hideeverything':
						uiIsHidden = true;
						break;
					case 'showeverything':
						uiIsHidden = false;
						break;
				}
				break;
			case 'rolleffect':
				addEffectToActive(E_RollExtraEffects);
				break;
		}
	}
}

/*
* This event handler ensures that RNG calls remain as chaotic at all times.
* While	the above event handler's RNG does not reset, this adds just an extra
* dash of unpredictability.
*/
Class TUC_EntropyMaintainer : StaticEventHandler
{
	int entropy;
	override void onRegister()
	{
		entropy = random(1, 35);
	}
	override void WorldTick()
	{
		if (gametic % entropy == 0) 
		{
			random(1, 100);
			entropy = random(1, 35);
		}
	}
}