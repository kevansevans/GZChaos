Class TUC_EventHandler : StaticEventHandler
{
	double effectTimer;
	double timer;
	
	bool pong;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	TUC_EventList list;
	
	Array<String> criticals;
	
	double prevForwardMove1;
	double prevForwardMove2;
	double prevSideMove1;
	double prevSideMove2;
	
	int timelimit;
	EffectInventory effects;
	
	bool uiIsHidden;
	bool cacoHitscan;

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		list = TUC_EventList.create();
		console.printf('Loading in ' .. (E_NumEvents) .. ' events!');
		
		timer = 0;
		
		criticals.clear();
	}
	
	void getPlayerInfo()
	{
		infoplayer = players[consoleplayer];
		player = infoplayer.mo;
	}
	
	void getEffects()
	{
		if (!player) getPlayerInfo();
		
		if (!player.countInv("EffectInventory"))
		{
			player.giveInventory('EffectInventory', 1);
		}
		
		effects = EffectInventory(player.findInventory("EffectInventory"));
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		uiIsHidden = false;
	
		getPlayerInfo();
		
		getEffects();
	
		if (effects.events.size())
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				TUC_Event event = effects.events[i];
				if (event.type == E_PerLevel || event.type == E_Instant || effects.events[i].deleteme)
				{
					removeEffect(event);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		if (!player) getPlayerInfo();
		
		if (!effects) getEffects();
		
		if (player.health > 0)
		{
			++timer;
		}
		
		timelimit = list.timelimit();
		
		if (list.timeLimit() - timer <= 0)
		{
			timer = 0;
			
			addEffectToActive();
		}
		
		for (inventory item = player.inv; item != null; item = item.inv)
		{	
			if (item is "EffectInventory")
			{
				effects = EffectInventory(item);
				break;
			}
		}
			
		if (player.health > 0)
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				if (player.health > 0)
				{
					if (!effects.events[i].activated) effects.events[i].eventFunc();
					if (effects.events[i].type == E_Instant) effects.events[i].activated = true;
					effects.events[i].life += 1;
					if (effects.events[i].life > effects.events[i].duration && effects.events[i].type != E_PerLevel)
					{
						removeEffect(effects.events[i]);
					}
				}
			}	
		}
		
		pong = player.countInv('TUC_PongToken');
		if (pong) runPong();
	}
	
	override void worldThingSpawned(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			TUC_Event event = effects.events[i];
			event.spawnFunc(_event.thing);
		}
	}
	
	void addEffectToActive(int _ignore = -1)
	{
		TUC_Event effect = list.getEffect(_ignore);
		effects.events.push(effect);
	}
	
	void removeEffect(TUC_Event _effect)
	{
		TUC_Event effect = _effect;
		effect.closeFunc();
		int place = effects.events.find(effect);
		effects.events.delete(place);
		effects.events.shrinkToFit();
		effect.destroy();
	}
	
	override void RenderUnderlay(RenderEvent event)
	{
		drawScreen();
	}
	
	bool ponginit;
	vector2 padApos;
	vector2 padBpos;
	vector2 ballpos;
	vector2 ballspeed;
	
	int ballradius;
	int paddleHeight;
	int paddleWidth;
	
	int leftScore;
	int rightScore;
	
	void runPong()
	{
		if (!ponginit)
		{
			ballradius = 12;
			ballpos = (Screen.getWidth() / 2, Screen.getHeight() / 2);
			
			double xspeed = 10 * cos(random(0, 359));
			double yspeed = 10 * cos(random(0, 359));
			
			ballspeed = (xspeed, yspeed);
			
			paddleWidth = 12;
			paddleHeight = 120;
			
			padAPos = (0, (Screen.getHeight() / 2) - (paddleHeight / 2));
			padBPos = (0, (Screen.getHeight() / 2) - (paddleHeight / 2));
			
			leftScore = 0;
			rightScore = 0;
			
			ponginit = true;
		}
		
		padAPos.x = 40;
		padBPos.x = Screen.getWidth() - 40 - paddleWidth;
		
		ballpos += ballspeed;
		
		if (ballpos.x < -20 || ballpos.x > Screen.getWidth() + 20)
		{
			if (ballpos.x < -20) ++rightScore;
			else ++leftScore;
		
			ballpos = (Screen.getWidth() / 2, Screen.getHeight() / 2);
			
			int angle = random(0, 359);
			
			double xspeed = 10 * cos(angle);
			double yspeed = 10 * sin(angle);
			
			ballspeed = (xspeed, yspeed);
		}
		
		if (ballpos.y - ballradius < 0 || ballpos.y + ballradius > Screen.getHeight()) 
		{
			
			ballspeed.y *= -1;
			player.A_StartSound("pong/wall", CHAN_AUTO);
		}
		
		if (ballspeed.x < 0 && ballPos.x < Screen.getWidth() / 2)
		{
			if (ballpos.y + ballradius > padAPos.y + paddleheight)
			{
				padAPos.y += min(10, (ballpos.y + ballradius) - (padAPos.y + paddleheight)); 
			}
			
			if (ballpos.y - ballradius < padAPos.y)
			{
				padAPos.y -= min(10, padAPos.y - ballpos.y - ballradius); 
			}
			
			padAPos.y = max(40 + paddleheight, padAPos.y);
			padAPos.y = min(Screen.getHeight() - 20 - (paddleheight / 2) , padAPos.y);
		
			if (ballpos.x - ballRadius < padApos.x + paddleWidth)
			{
				if (ballpos.y - ballradius > padAPos.y - (paddleHeight / 2) &&
					ballpos.y + ballradius < padAPos.y + (paddleheight / 2))
				{
					int aangle = random(0, 359);
				
					double xspeed = 10 * cos(aangle);
					double yspeed = 10 * sin(aangle);
					if (xspeed < 0) xspeed *= -1;
					
					ballspeed = (xspeed, yspeed);
					
					player.A_StartSound("pong/paddle", CHAN_AUTO);
				}
			}
		}
		
		if (ballspeed.x > 0 && ballPos.x > Screen.getWidth() / 2)
		{
			if (ballpos.y + ballradius > padBPos.y + paddleheight)
			{
				padBPos.y += min(10, (ballpos.y + ballradius) - (padBPos.y + paddleheight)); 
			}
			
			if (ballpos.y - ballradius < padBPos.y)
			{
				padBPos.y -= min(10, padBPos.y - ballpos.y - ballradius); 
			}
			
			padBPos.y = max(40 + paddleheight, padBPos.y);
			padBPos.y = min(Screen.getHeight() - 20 - (paddleheight / 2) , padBPos.y);
			
			
			if (ballpos.x + ballRadius > padBpos.x - paddleWidth)
			{
				if (ballpos.y - ballradius > padBpos.y - (paddleHeight / 2) &&
					ballpos.y + ballradius < padBpos.y + (paddleheight / 2))
				{
					int bangle = random(0, 359);
				
					double xspeed = 10 * cos(bangle);
					double yspeed = 10 * sin(bangle);
					if (xspeed > 0) xspeed *= -1;
					
					ballspeed = (xspeed, yspeed);
					
					player.A_StartSound("pong/paddle", CHAN_AUTO);
				}
			}
			
		}
		
		padAPos.y = max(40, padAPos.y);
		padAPos.y = min(Screen.getHeight() - 40, padAPos.y);
		padBPos.y = max(40, padBPos.y);
		padBPos.y = min(Screen.getHeight() - 40, padBPos.y);
	}
	
	override void RenderOverlay(RenderEvent event)
	{
		//drawScreen();
		
		if (pong)
		{
			Screen.drawThickLine(ballpos.x - ballradius, ballpos.y - ballradius, ballpos.x + ballradius, ballpos.y - ballradius, ballradius * 2, Color("FFFFFF"));
			
			Screen.drawThickLine(padAPos.x, padAPos.y - (paddleHeight / 2), padAPos.x + paddleWidth, padAPos.y - (paddleHeight / 2), paddleHeight, Color("FFFFFF"));
			Screen.drawThickLine(padBPos.x, padBPos.y - (paddleHeight / 2), padBPos.x + paddleWidth, padBPos.y - (paddleHeight / 2), paddleHeight, Color("FFFFFF"));
			
			Screen.drawThickLine(Screen.getWidth() / 2 - 2, -10, Screen.getWidth() / 2 + 2, -10, Screen.getHeight() * 2 + 40, Color("FFFFFF"));
			
			Screen.DrawText(BIGFONT, Font.CR_WHITE, Screen.getWidth() / 2 - 80, 20, '' .. leftScore, DTA_ScaleX, 5, DTA_ScaleY, 5);
			Screen.DrawText(BIGFONT, Font.CR_WHITE, Screen.getWidth() / 2 + 20, 20, '' .. rightScore, DTA_ScaleX, 5, DTA_ScaleY, 5);
		}
	}
	
	ui void drawScreen()
	{
		if (!player) return;
		
		if (!uiIsHidden)
		{
			double ratio = timer / timeLimit;
			double width = ratio * double(Screen.getWidth());
			Screen.DrawThickLine(0, 5, width, 5, 10, Color("00CC00"));
		}
		
		if (!effects) return;
		if (effects.events.size() > 0)
		{
			int yOffset = 150;
			for (int i = 0; i < effects.events.size(); ++i)
			{
				if (uiIsHidden && !(effects.events[i] is "TUC_HideTimerAndEffects")) continue;
			
				TUC_Event effect = effects.events[i];
				Screen.DrawText(BIGFONT, Font.CR_White, 20, (yoffset - 20), effect.eventname, DTA_ScaleX, 1.5, DTA_ScaleY, 1.5);
				if (effects.events[i].type == E_Timed)
				{
					double ratio = 1 - (double(effect.life) / double(effect.duration));
					Screen.DrawThickLine(20, yOffset += 10, 20 + (200 * ratio), yOffset, 10, color("FF0000"), 255);
				}
				yOffset += 60;
			}
		}
	}
	
	override void NetworkProcess(ConsoleEvent event)
	{
		infoplayer = players[event.Player];
		player = infoplayer.mo;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		Array<string> command;
		event.name.Split (command, ":");
		
		switch (name(command[0]))
		{
			case 'meta':
				switch (name(command[1]))
				{
					case 'speedup':
						list.timemodifier /= command[2].toDouble();
						break;
					case 'slowdown':
						list.timemodifier *= command[2].toDouble();
						break;
					case 'hideeverything':
						uiIsHidden = true;
						break;
					case 'showeverything':
						uiIsHidden = false;
						break;
					case 'pongon':
						pong = true;
						break;
					case 'pongoff':
						ponginit = false;
						pong = false;
						break;
				}
				break;
			case 'rolleffect':
				addEffectToActive(E_RollExtraEffects);
				break;
		}
	}
}

/*
* This event handler ensures that RNG calls remain as chaotic at all times.
* While	the above event handler's RNG does not reset, this adds just an extra
* dash of unpredictability.
*/
Class TUC_EntropyMaintainer : StaticEventHandler
{
	int entropy;
	override void onRegister()
	{
		entropy = random(1, 35);
	}
	override void WorldTick()
	{
		if (gametic % entropy == 0) 
		{
			random(1, 100);
			entropy = random(1, 35);
		}
	}
}