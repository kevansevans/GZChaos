Class GZC_EventHandler : StaticEventHandler
{
	double effectTimer;
	double timer;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	GZC_EventList list;
	
	Array<String> criticals;
	
	double prevForwardMove1;
	double prevForwardMove2;
	double prevSideMove1;
	double prevSideMove2;
	
	int timelimit;
	EffectInventory effects;
	
	bool uiIsHidden;
	bool pong;
	bool superhot;
	
	override void NewGame()
	{
		list = GZC_EventList.create();
	}

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		timer = 0;
		
		criticals.clear();
	}
	
	void getPlayerInfo()
	{
		infoplayer = players[consoleplayer];
		player = infoplayer.mo;
	}
	
	void getEffects()
	{
		if (!player) getPlayerInfo();
		
		if (!player.countInv("EffectInventory"))
		{
			player.giveInventory('EffectInventory', 1);
		}
		
		effects = EffectInventory(player.findInventory("EffectInventory"));
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		getPlayerInfo();
		
		getEffects();
	
		if (effects.events.size())
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				GZC_Event event = effects.events[i];
				if (event.type == E_PerLevel || event.type == E_Instant || effects.events[i].deleteme)
				{
					removeEffect(event);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		if (level.LevelNum == 999) return;
	
		if (!player) getPlayerInfo();
		
		if (!effects) getEffects();
		
		for (inventory item = player.inv; item != null; item = item.inv)
		{	
			if (item is "EffectInventory")
			{
				effects = EffectInventory(item);
				break;
			}
		}
			
		if (player.health > 0)
		{
			
			if (!player.countInv('GZC_SuperHotToken'))
			{
				performModTic();
			}
			else
			{
				performTimeScale();
			}
		}
		
		pong = player.countInv('GZC_PongToken');
		if (pong) runPong();
		
		uiIsHidden = player.countInv('GZC_HideTimerToken');
	}
	
	void performModTic()
	{
		++timer;
		
		timelimit = list.timelimit();
		
		if (list.timeLimit() - timer <= 0)
		{
			timer = 0;
			
			addEffectToActive();
		}
	
		for (int i = 0; i < effects.events.size(); ++i)
		{
			if (player.health > 0)
			{
				if (!effects.events[i].activated && effects.events[i].life < effects.events[i].duration) effects.events[i].eventFunc();
				if (effects.events[i].type == E_Instant) effects.events[i].activated = true;
				effects.events[i].life += 1;
				if (effects.events[i].life == effects.events[i].duration)
				{
					effects.events[i].closeFunc();
				}
				if (effects.events[i].life > (effects.events[i].duration + (35 * 30)) && effects.events[i].type != E_PerLevel)
				{
					removeEffect(effects.events[i]);
				}
			}
		}	
	}
	
	override void worldThingSpawned(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			event.spawnFunc(_event.thing);
		}
	}
	
	void addEffectToActive(int _ignore = -1)
	{
		GZC_Event effect = list.getEffect(_ignore);
		effects.events.push(effect);
	}
	
	void removeEffect(GZC_Event _effect)
	{
		GZC_Event effect = _effect;
		int place = effects.events.find(effect);
		effects.events.delete(place);
		effects.events.shrinkToFit();
		effect.destroy();
	}
	
	override void RenderUnderlay(RenderEvent event)
	{
		if (level.LevelNum == 999) return;
	
		if (!uiIsHidden)
		{
			double ratio = timer / timeLimit;
			double width = ratio * double(Screen.getWidth());
			Screen.DrawThickLine(0, 5, width, 5, 10, Color("00CC00"));
		}
	}
	
	ThinkerIterator it;
	double mytics;
	int myticsint;
	
	void performTimeScale()
	{
		double playerspeed = sqrt((player.vel.x * player.vel.x) + (player.vel.y * player.vel.y) + (player.vel.z * player.vel.z));
		double ticdelta = min(1, playerspeed / 20);

		mytics += ticdelta;

		int catchup = (int(mytics) - int(myticsint)) - 1;

		if (!it)
			it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		else
			it.Reinit();
	
		bool tickmod = false;

		actor mo;
		while (mo = Actor(it.Next()))
		{
			if (mo.isFrozen()) break;

			if ((catchup < 0))
			{
				if (mo.tics > 0 && mo.freezetics < 1) mo.freezetics = 1;
			}
			else
			{
				tickmod = true;
			}
			
			int thiscatchup = catchup;
			while (thiscatchup-- > 0)
			{
				if (mo.tics > 0)
				{
					mo.Tick();
				}
			}
		}
		
		if (tickmod) {
			performModTic();
		}
		
		myticsint += catchup + 1;
	}
	
	bool ponginit;
	vector2 padApos;
	vector2 padBpos;
	vector2 ballpos;
	vector2 ballspeed;
	
	int ballradius;
	int paddleHeight;
	int paddleWidth;
	
	int leftScore;
	int rightScore;
	
	void runPong()
	{
		if (!ponginit)
		{
			ballradius = 12;
			ballpos = (Screen.getWidth() / 2, Screen.getHeight() / 2);
			
			double xspeed = 10 * cos(random(0, 359));
			double yspeed = 10 * cos(random(0, 359));
			
			ballspeed = (xspeed, yspeed);
			
			paddleWidth = 12;
			paddleHeight = 120;
			
			padAPos = (0, (Screen.getHeight() / 2) - (paddleHeight / 2));
			padBPos = (0, (Screen.getHeight() / 2) - (paddleHeight / 2));
			
			leftScore = 0;
			rightScore = 0;
			
			ponginit = true;
		}
		
		padAPos.x = 40;
		padBPos.x = Screen.getWidth() - 40 - paddleWidth;
		
		ballpos += ballspeed;
		
		if (ballpos.x < -20 || ballpos.x > Screen.getWidth() + 20)
		{
			if (ballpos.x < -20) ++rightScore;
			else ++leftScore;
		
			ballpos = (Screen.getWidth() / 2, Screen.getHeight() / 2);
			
			int angle = random(0, 359);
			
			double xspeed = 10 * cos(angle);
			double yspeed = 10 * sin(angle);
			
			ballspeed = (xspeed, yspeed);
		}
		
		if (ballpos.y - ballradius < 0 || ballpos.y + ballradius > Screen.getHeight()) 
		{
			
			ballspeed.y *= -1;
			player.A_StartSound("pong/wall", CHAN_AUTO);
		}
		
		if (ballspeed.x < 0 && ballPos.x < Screen.getWidth() / 2)
		{
			if (ballpos.y + ballradius > padAPos.y + paddleheight)
			{
				padAPos.y += min(10, (ballpos.y + ballradius) - (padAPos.y + paddleheight)); 
			}
			
			if (ballpos.y - ballradius < padAPos.y)
			{
				padAPos.y -= min(10, padAPos.y - ballpos.y - ballradius); 
			}
			
			padAPos.y = max(40 + paddleheight, padAPos.y);
			padAPos.y = min(Screen.getHeight() - 20 - (paddleheight / 2) , padAPos.y);
		
			if (ballpos.x - ballRadius < padApos.x + paddleWidth)
			{
				if (ballpos.y - ballradius > padAPos.y - (paddleHeight / 2) &&
					ballpos.y + ballradius < padAPos.y + (paddleheight / 2))
				{
					int aangle = random(0, 359);
				
					double xspeed = 10 * cos(aangle);
					double yspeed = 10 * sin(aangle);
					if (xspeed < 0) xspeed *= -1;
					
					ballspeed = (xspeed, yspeed);
					
					player.A_StartSound("pong/paddle", CHAN_AUTO);
				}
			}
		}
		
		if (ballspeed.x > 0 && ballPos.x > Screen.getWidth() / 2)
		{
			if (ballpos.y + ballradius > padBPos.y + paddleheight)
			{
				padBPos.y += min(10, (ballpos.y + ballradius) - (padBPos.y + paddleheight)); 
			}
			
			if (ballpos.y - ballradius < padBPos.y)
			{
				padBPos.y -= min(10, padBPos.y - ballpos.y - ballradius); 
			}
			
			padBPos.y = max(40 + paddleheight, padBPos.y);
			padBPos.y = min(Screen.getHeight() - 20 - (paddleheight / 2) , padBPos.y);
			
			
			if (ballpos.x + ballRadius > padBpos.x - paddleWidth)
			{
				if (ballpos.y - ballradius > padBpos.y - (paddleHeight / 2) &&
					ballpos.y + ballradius < padBpos.y + (paddleheight / 2))
				{
					int bangle = random(0, 359);
				
					double xspeed = 10 * cos(bangle);
					double yspeed = 10 * sin(bangle);
					if (xspeed > 0) xspeed *= -1;
					
					ballspeed = (xspeed, yspeed);
					
					player.A_StartSound("pong/paddle", CHAN_AUTO);
				}
			}
			
		}
		
		padAPos.y = max(40, padAPos.y);
		padAPos.y = min(Screen.getHeight() - 40, padAPos.y);
		padBPos.y = max(40, padBPos.y);
		padBPos.y = min(Screen.getHeight() - 40, padBPos.y);
	}
	
	override void RenderOverlay(RenderEvent event)
	{
		if (player.countInv("GZC_PortraitModeToken"))
		{
			double ratio = Screen.getHeight() * (9.0 / 16.0);
			
			Screen.drawThickLine(0, 0, (Screen.getWidth() / 2) - (ratio / 2), 0, Screen.getHeight() * 2 + 40, Color("000000"));
			Screen.drawThickLine((Screen.getWidth() / 2) + (ratio / 2), 0, Screen.getWidth(), 0, Screen.getHeight() * 2 + 40, Color("000000"));
		}
		
		drawScreen();
		
		if (pong)
		{
			Screen.drawThickLine(ballpos.x - ballradius, ballpos.y - ballradius, ballpos.x + ballradius, ballpos.y - ballradius, ballradius * 2, Color("FFFFFF"));
			
			Screen.drawThickLine(padAPos.x, padAPos.y - (paddleHeight / 2), padAPos.x + paddleWidth, padAPos.y - (paddleHeight / 2), paddleHeight, Color("FFFFFF"));
			Screen.drawThickLine(padBPos.x, padBPos.y - (paddleHeight / 2), padBPos.x + paddleWidth, padBPos.y - (paddleHeight / 2), paddleHeight, Color("FFFFFF"));
			
			Screen.drawThickLine(Screen.getWidth() / 2 - 2, -10, Screen.getWidth() / 2 + 2, -10, Screen.getHeight() * 2 + 40, Color("FFFFFF"));
			
			Screen.DrawText(BIGFONT, Font.CR_WHITE, Screen.getWidth() / 2 - 80, 20, '' .. leftScore, DTA_ScaleX, 5, DTA_ScaleY, 5);
			Screen.DrawText(BIGFONT, Font.CR_WHITE, Screen.getWidth() / 2 + 20, 20, '' .. rightScore, DTA_ScaleX, 5, DTA_ScaleY, 5);
		}
	}
	
	ui void drawScreen()
	{
		if (!player) return;
		
		if (!effects) return;
		if (effects.events.size() > 0)
		{
			int yOffset = 150;
			for (int i = 0; i < effects.events.size(); ++i)
			{
				if (uiIsHidden && !(effects.events[i] is "GZC_HideTimerAndEffects")) continue;
			
				GZC_Event effect = effects.events[i];
				int fontcolor = Font.CR_White;
				
				if (effect.life > effect.duration || effect.type != E_Timed) fontcolor = Font.CR_DarkGray;
				if (effect.life < 35) fontcolor = Font.CR_Yellow;
				
				Screen.DrawText(BIGFONT, fontcolor, 20, (yoffset - 20), effect.eventname, DTA_ScaleX, 1.5, DTA_ScaleY, 1.5);
				if (effect.type == E_Timed && effect.life < effect.duration)
				{
					double ratio = 1 - (double(effect.life) / double(effect.duration));
					Screen.DrawThickLine(20, yOffset += 10, 20 + (200 * ratio), yOffset, 10, color("FF0000"), 255);
				}
				yOffset += 60;
			}
		}
	}
}

/*
* This event handler ensures that RNG calls remain as chaotic at all times.
* While	the above event handler's RNG does not reset, this event below
* adds just an extra dash of unpredictability.
*/
Class GZC_EntropyMaintainer : StaticEventHandler
{
	int entropy;
	override void onRegister()
	{
		entropy = random(1, 35);
	}
	override void WorldTick()
	{
		if (gametic % entropy == 0) 
		{
			random(1, 100);
			entropy = random(1, 35);
		}
	}
	override void newGame()
	{
		int rand = random(1, 10);
		for (int i = 0; i < rand; ++i)
		{
			int rand2 = random(1, 10);
			for (int i = 0; i < rand2; ++i)
			{
				int rand3 = random(1, 10);
			}
		}
	}
}