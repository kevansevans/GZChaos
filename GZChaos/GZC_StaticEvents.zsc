Class GZC_EventHandler : StaticEventHandler
{
	double effectTimer;
	double timer;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	GZC_EventList list;
	
	int timelimit;
	EffectInventory effects;
	
	bool superhot;
	
	int kills;
	
	int timerMode;
	
	override void NewGame()
	{
		getEffectsList();
	}
	
	void getEffectsList()
	{
		if (!effects)
		{
			list = GZC_EventList.create();
			timerMode = E_Normal;
			timer = 0;
		}
	}

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		timer = 0;
		
		SetOrder(100);
	}
	
	void getPlayerInfo()
	{
		infoplayer = players[consoleplayer];
		player = infoplayer.mo;
	}
	
	void getEffects()
	{
		getEffectsList();
	
		if (!player) getPlayerInfo();
		
		if (!player.countInv("EffectInventory"))
		{
			player.giveInventory('EffectInventory', 1);
		}
		
		effects = EffectInventory(player.findInventory("EffectInventory"));
	}
	
	int getEnabledEffectsCount()
	{
		int count;
		foreach (effect : effects.events)
		{
			if (effect.life > effect.duration || effect.type != E_Timed) continue;
			++count;
		}
		return count;
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		getPlayerInfo();
		
		getEffects();
	
		if (effects.events.size())
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				GZC_Event event = effects.events[i];
				if (event.type == E_PerLevel || event.type == E_Instant || event.deleteme || !event.verify())
				{
					if (event.life < event.duration)
					{
						event.closeFunc();
					}
					removeEffect(event);
				}
				else
				{
					event.loadFunc();
				}
			}
		}
	}
	
	bool set;
	
	override void WorldTick()
	{
		if (!player) getPlayerInfo();
		
		if (!effects) getEffects();
		
		if (cvar.getCvar('gzc_addeffect').getString() != "")
		{
			let value = cvar.getCvar('gzc_addeffect').getString();
			cvar.getCvar('gzc_addeffect').setString("");
			for (int i; i < list.events.size(); ++i)
			{
				if (list.events[i].makeUpper().IndexOf(value.MakeUpper()) != -1)
				{
					let effect = GZC_Event(new(list.events[i]));
					effect.init();
					bool verified = effect.verify();
					if (!verified) console.printf('Warning: Effect "' .. effect.eventname .. '" resolved false under verification!');
					effects.events.push(effect);
					return;
				}
			}
			console.printf('No effect ' .. value .. ' found');
		}
		
		for (inventory item = player.inv; item != null; item = item.inv)
		{	
			if (item is "EffectInventory")
			{
				effects = EffectInventory(item);
				break;
			}
		}
		
		timelimit = list.timelimit();
			
		if (player.health > 0)
		{
			
			switch (timerMode)
			{
				case E_Normal:
					performModTic();
					break;
				case E_SuperHot:
					performTimeScale();
					break;
				case E_PerKill:
					if (kills)
					{
						performModTic(35);
						--kills;
					}
					else
					{
						performModTic(0);
					}
					break;
			}
		}
	}
	
	void performModTic(int steps = 1)
	{
		int maxed = Cvar.getCvar('GZC_MaxEffects').getInt();
	
		if (!Cvar.getCvar('gzc_pausemaintimer').getBool()) 
		{
			if (maxed != 0 && getEnabledEffectsCount() >= maxed){}
			else
			{
				timer += steps;
			}
		}
		
		if (list.timeLimit() - timer <= 0)
		{
			timer = 0;
			
			addEffectToActive();
		}
	
		for (int i = 0; i < effects.events.size(); ++i)
		{
			if (player.health > 0)
			{
				if (!effects.events[i].activated && effects.events[i].life < effects.events[i].duration)
				{
					effects.events[i].eventFunc();
				}
				if (effects.events[i].type == E_Instant) 
				{
					effects.events[i].activated = true;
				}
				if (!Cvar.getCvar('gzc_pauseeffecttimer').getBool()) 
				{
					effects.events[i].life += steps;
				}
				if (effects.events[i].life >= effects.events[i].duration && !effects.events[i].deadEffect)
				{
					effects.events[i].closeFunc();
					effects.events[i].deadEffect = true;
				}
				if (effects.events[i].life > (effects.events[i].duration + (35 * 30)) && effects.events[i].type != E_PerLevel)
				{
					removeEffect(effects.events[i]);
				}
			}
		}	
	}
	
	override void WorldThingDied(WorldEvent _event)
	{
		if (_event.thing.target is "PlayerPawn" && timermode == E_PerKill)
		{
			++kills;
		}
		
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (!effects.events[i].activated && effects.events[i].life < effects.events[i].duration) event.deathFunc(_event.thing);
		}
	}
	
	override void worldThingSpawned(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (!effects.events[i].activated && effects.events[i].life < effects.events[i].duration) event.spawnFunc(_event.thing);
		}
	}
	
	void addEffectToActive(int _ignore = -1)
	{
		if (Cvar.getCvar('GZC_Debug', player.player).getBool())
		{
			console.printf('Debug mode active, no effect rolled.');
			return;
		}
	
		GZC_Event effect = list.getEffect(_ignore);
		effects.events.push(effect);
	}
	
	void removeEffect(GZC_Event _effect)
	{
		GZC_Event effect = _effect;
		int place = effects.events.find(effect);
		effects.events.delete(place);
		effects.events.shrinkToFit();
		effect.destroy();
	}
	
	ThinkerIterator it;
	double mytics;
	int myticsint;
	
	void performTimeScale()
	{
		double playerspeed = sqrt((player.vel.x * player.vel.x) + (player.vel.y * player.vel.y) + (player.vel.z * player.vel.z));
		double ticdelta = min(1, playerspeed / 20);

		mytics += ticdelta;

		int catchup = (int(mytics) - int(myticsint)) - 1;

		if (!it)
			it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		else
			it.Reinit();
	
		bool tickmod = false;

		actor mo;
		while (mo = Actor(it.Next()))
		{
			if (mo.isFrozen()) break;

			if ((catchup < 0))
			{
				if (mo.tics > 0 && mo.freezetics < 1) mo.freezetics = 1;
			}
			else
			{
				tickmod = true;
			}
			
			int thiscatchup = catchup;
			while (thiscatchup-- > 0)
			{
				if (mo.tics > 0)
				{
					mo.Tick();
				}
			}
		}
		
		if (tickmod) {
			performModTic();
		}
		
		myticsint += catchup + 1;
	}
}

enum E_TimerMode
{
	E_Normal,
	E_SuperHot,
	E_PerKill
}

/*
* This event handler ensures that RNG calls remain as chaotic at all times.
* While	the above event handler's RNG does not reset, this event below
* adds just an extra dash of unpredictability.
*/
Class GZC_EntropyMaintainer : StaticEventHandler
{
	int entropy;
	override void onRegister()
	{
		entropy = random(1, 35);
	}
	override void WorldTick()
	{
		if (gametic % entropy == 0) 
		{
			random(1, 100);
			entropy = random(1, 35);
		}
	}
	override void newGame()
	{
		int rand = random(1, 10);
		for (int i = 0; i < rand; ++i)
		{
			int rand2 = random(1, 10);
			for (int i = 0; i < rand2; ++i)
			{
				int rand3 = random(1, 10);
			}
		}
	}
}