Class GZC_EventHandler : StaticEventHandler
{
	double effectTimer;
	
	PlayerPawn player;
	PlayerInfo infoplayer;
	
	GZC_EventList list;
	
	int timelimit;
	EffectInventory effects;
	
	bool superhot;
	
	int kills;
	
	int timerMode;
	
	bool showseed;
	
	int suffering;
	int conquered;
	
	override void NewGame()
	{
		getEffectsList();
		
		showseed = true;
		
		GZC_ShaderEvent.DisableShaders();
	}
	
	override void WorldLoaded(WorldEvent _event)
	{
		GZC_ShaderEvent.DisableShaders();
		
		if (!_event.isSaveGame) ++conquered;
	}
	
	void getEffectsList()
	{
		if (!effects)
		{
			list = GZC_EventList.create();
			timerMode = E_Normal;
			
			suffering = 0;
			conquered = 0;
		}
	}

	override void OnRegister()
	{
		console.printf('Let the Chaos begin!');
		
		SetOrder(1);
	}
	
	void getPlayerInfo()
	{
		infoplayer = players[consoleplayer];
		player = infoplayer.mo;
	}
	
	void getEffects()
	{
		getEffectsList();
	
		if (!player) getPlayerInfo();
		
		bool showseed;
		if (!player.countInv("EffectInventory"))
		{
			player.giveInventory('EffectInventory', 1);
			showseed = true;
		}
		
		effects = EffectInventory(player.findInventory("EffectInventory"));
	}
	
	int getEnabledEffectsCount()
	{
		int count;
		foreach (effect : effects.events)
		{
			if (effect.life > effect.duration || effect.type != E_Timed) continue;
			++count;
		}
		return count;
	}
	
	override void PlayerEntered(PlayerEvent event)
	{
		getPlayerInfo();
		
		getEffects();
	
		if (effects.events.size())
		{
			for (int i = 0; i < effects.events.size(); ++i)
			{
				GZC_Event event = effects.events[i];
				if (event.type == E_PerLevel || event.type == E_Instant || event.deleteme)
				{
					if (event.life < event.duration)
					{
						event.closeFunc();
					}
					removeEffect(event);
				}
				else
				{
					event.loadFunc();
				}
			}
		}
	}
	
	bool set;
	
	override void WorldTick()
	{
		if (level.levelnum == 0) return;
	
		if (level.isFrozen()) return;
	
		if (!player) getPlayerInfo();
		
		if (!effects) getEffects();
		
		showSeedEvent();
		
		for (inventory item = player.inv; item != null; item = item.inv)
		{	
			if (item is "EffectInventory")
			{
				effects = EffectInventory(item);
				break;
			}
		}
		
		timelimit = list.timelimit();
			
		if (player.health > 0)
		{
			
			switch (timerMode)
			{
				case E_Normal:
					performModTic();
					break;
				case E_SuperHot:
					performTimeScale();
					break;
				case E_PerKill:
					if (kills)
					{
						performModTic(35);
						--kills;
					}
					else
					{
						performModTic(0);
					}
					break;
			}
		}
		
		if (cvar.getCvar('gzc_addeffect') && cvar.getCvar('gzc_addeffect').getString() != "")
		{
			let value = cvar.getCvar('gzc_addeffect').getString();
			cvar.getCvar('gzc_addeffect').setString("");
			for (int i; i < list.events.size(); ++i)
			{
				if (list.events[i].makeUpper().IndexOf(value.MakeUpper()) != -1)
				{
					let effect = GZC_Event(new(list.events[i]));
					effect.init();
					bool verified = effect.verify();
					if (!verified) console.printf('Warning: Effect "' .. effect.eventname .. '" resolved false under verification!');
					effects.events.push(effect);
					return;
				}
			}
			console.printf('No effect ' .. value .. ' found');
		}
	}
	
	void showSeedEvent()
	{
		if (!Cvar.getCvar('GZC_ShowSeedAtStart', players[consoleplayer])) return;
		if (!Cvar.getCvar('GZC_UseSeed', players[consoleplayer])) return;
		if (!Cvar.getCvar('GZC_ShowSeedAtStart', players[consoleplayer]).getBool()) return;
		if (!Cvar.getCvar('GZC_UseSeed', players[consoleplayer]).getBool()) return;
		
		if (!showSeed) return;
		
		let seedevent = new('GZC_SeedInfo');
		seedevent.init();
		effects.events.push(seedevent);
		showseed = false;
	}
	
	void performModTic(int steps = 1)
	{
		int maxed = Cvar.getCvar('GZC_MaxEffects').getInt();
		let player = players[consoleplayer].mo;
	
		if (!Cvar.getCvar('gzc_pausemaintimer').getBool()) 
		{
			if (maxed != 0 && getEnabledEffectsCount() >= maxed){}
			else
			{
				player.giveInventory('TimerToken', steps);
			}
		}
		
		if (list.timeLimit() - player.countInv('TimerToken') <= 0)
		{
			player.takeInventory('TimerToken', 0x7FFFFFFF);
			
			addEffectToActive();
		}
	
		for (int i = 0; i < effects.events.size(); ++i)
		{
			if (!effects.events[i]) continue;
		
			if (player.health > 0)
			{
				if (effects.events[i].life < effects.events[i].duration)
				{
					effects.events[i].eventFunc();
				}
				if (!Cvar.getCvar('gzc_pauseeffecttimer').getBool()) 
				{
					effects.events[i].life += steps;
				}
				if (effects.events[i].life >= effects.events[i].duration && !effects.events[i].deadEffect)
				{
					effects.events[i].closeFunc();
					effects.events[i].deadEffect = true;
				}
				if (effects.events[i].life > (effects.events[i].duration + (35 * 30)) && effects.events[i].type != E_PerLevel)
				{
					removeEffect(effects.events[i]);
				}
			}
		}	
	}
	
	override void WorldThingDied(WorldEvent _event)
	{
		if (_event.thing.target is "PlayerPawn" && timermode == E_PerKill)
		{
			++kills;
		}
		
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (effects.events[i].life < effects.events[i].duration) event.deathFunc(_event.thing);
		}
	}
	
	override void worldThingSpawned(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (effects.events[i].life < effects.events[i].duration) event.spawnFunc(_event.thing);
		}
	}
	
	override void worldLinePreActivated(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (effects.events[i].life < effects.events[i].duration) event.preActivateLine(_event);
		}
	}
	
	override void WorldThingDamaged(WorldEvent _event)
	{
		if (!player) getPlayerInfo();
		if (!effects) getEffects();
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (effects.events[i].life < effects.events[i].duration) event.damageFunc(_event);
		}
	}
	
	void addEffectToActive(int _ignore = -1)
	{
		if (Cvar.getCvar('GZC_Debug', player.player).getBool())
		{
			console.printf('Debug mode active, no effect rolled.');
			return;
		}
	
		GZC_Event effect = list.getEffect(_ignore);
		effects.events.push(effect);
		effect.openFunc();
		++suffering;
	}
	
	void removeEffect(GZC_Event _effect)
	{
		GZC_Event effect = _effect;
		int place = effects.events.find(effect);
		effects.events.delete(place);
		effects.events.shrinkToFit();
		effect.destroy();
	}
	
	ui double darkness;
	ui int snapshot;
	override void RenderOverlay(RenderEvent _event)
	{
		let player = players[consoleplayer].mo;
		
		if (player.health > 0)
		{
			return;
		}
		
		if (snapshot == 0) snapshot = gametic;
		
		double sufscale = double(Screen.getWidth()) / 1600.0;
		double mid = (Screen.getWidth() / 2) - (1535 / 2 * sufscale);
		
		Screen.DrawTexture(TexMan.CheckFOrTexture('SUFFER'), false, mid, 10, DTA_ScaleX, sufscale, DTA_ScaleY, sufscale);
		
		int seconds = int(snapshot / 35);
		int rseconds = snapshot % 35;
		int minutes = int(seconds / 60);
		int hours = int(minutes / 60);
		
		string min = minutes < 10 ? "0" .. minutes : "" .. minutes;
		string sec = rseconds < 10 ? "0" .. rseconds : "" .. rseconds;
		
		double screenscale = double(Screen.getWidth()) / 2560.0;
		string playername = player.player.getUserName();
		string statinfo = playername .. " suffered through " .. self.suffering .. " effects\nand persevered through " .. (self.conquered - 1) .. " maps.\nPlaytime: " .. hours .. ":" .. minutes .. ":" .. sec;
		double statsize = BigFont.StringWidth(statinfo);
		
		double offsetx = (double(Screen.getWidth()) / 2) - (statsize / 2);
		
		Screen.DrawText(BigFont, Font.CR_Brick, offsetx, 20 + (190 * sufscale), statinfo);
	}
	
	ThinkerIterator it;
	double mytics;
	int myticsint;
	
	void performTimeScale()
	{
		double playerspeed = sqrt((player.vel.x * player.vel.x) + (player.vel.y * player.vel.y) + (player.vel.z * player.vel.z));
		double ticdelta = min(1, playerspeed / 20);

		mytics += ticdelta;

		int catchup = (int(mytics) - int(myticsint)) - 1;

		if (!it)
			it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		else
			it.Reinit();
	
		bool tickmod = false;

		actor mo;
		while (mo = Actor(it.Next()))
		{
			if (mo.isFrozen()) break;

			if ((catchup < 0))
			{
				if (mo.tics > 0 && mo.freezetics < 1) mo.freezetics = 1;
			}
			else
			{
				tickmod = true;
			}
			
			int thiscatchup = catchup;
			while (thiscatchup-- > 0)
			{
				if (mo.tics > 0)
				{
					mo.Tick();
				}
			}
		}
		
		if (tickmod) {
			performModTic();
		}
		
		myticsint += catchup + 1;
	}
}

enum E_TimerMode
{
	E_Normal,
	E_SuperHot,
	E_PerKill
}

/*
* This event handler ensures that RNG calls remain as chaotic at all times.
* While	the above event handler's RNG does not reset, this event below
* adds just an extra dash of unpredictability.
*/
Class GZC_EntropyMaintainer : StaticEventHandler
{
	int entropy;
	override void onRegister()
	{
		entropy = random(1, 35);
	}
	override void WorldTick()
	{
		if (gametic % entropy == 0) 
		{
			random(1, 100);
			entropy = random(1, 35);
		}
	}
	override void newGame()
	{
		int rand = random(1, 10);
		for (int i = 0; i < rand; ++i)
		{
			int rand2 = random(1, 10);
			for (int i = 0; i < rand2; ++i)
			{
				int rand3 = random(1, 10);
			}
		}
	}
}