Class GZC_NoSplashDamage : GZC_Event
{
	void negate(Actor mo)
	{
		mo.bNoRadiusDMG = true;
	}
	
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			negate(mo);
		}
	}
	
	override void spawnFunc(Actor mo)
	{
		negate(mo);
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.bNoRadiusDMG = def.bNoRadiusDMG;
		}
	}
	
	override void init()
	{
		eventname = "Ineffective Splash Damage";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_EnemySpeedEffect : GZC_Event
{
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_EnemySpeedEffect') return false;
		}
		
		return result;
	}
}

Class GZC_RandomEnemySpeed : GZC_EnemySpeedEffect
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.speed = random(int(-def.speed * 2), int(def.speed * 2));
		}
		
		activated = true;
	}
	
	override void spawnFunc(Actor mo)
	{
		let def = getDefaultByType(mo.getClass());
		mo.speed = random(int(-def.speed * 2), int(def.speed * 2));
	}
	
	override void loadFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.speed = random(int(-def.speed * 2), int(def.speed * 2));
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
		
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed;
		}
	}

	override void init()
	{
		eventname = "??? Speed Monsters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_NegativeEnemySpeed : GZC_EnemySpeedEffect
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed * -1;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
		
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed;
		}
	}

	override void init()
	{
		eventname = "-1x Speed Monsters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_HalfEnemySpeed : GZC_EnemySpeedEffect
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.speed = int(def.speed / 2);
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
		
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed;
		}
	}

	override void init()
	{
		eventname = "1/2 Speed Monsters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_DoubleEnemySpeed : GZC_EnemySpeedEffect
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
		
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed * 2;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
		
			let def = getDefaultByType(mo.getClass());
			mo.speed = def.speed;
		}
	}

	override void init()
	{
		eventname = "2x Speed Monsters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_AAAAAHHHHH : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		let player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			if (mo.health <= 0) continue;
			if (mo is 'GZC_KamikaziGuy') continue;
			
			morphActor(mo, 'GZC_KamikaziGuy');
			
			mo.target = player;
			mo.A_FaceTarget();
		}
		
		activated = true;
	}

	override void init()
	{
		eventname = "AAAAAHHHHH";
		duration = 35 * 5;
		type = E_Timed;
	}
}

Class GZC_BarrelsOFun : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			if (mo.health <= 0) continue;
			if (mo is 'GZC_ExplosiveBarrel') continue;
			mo.A_Morph('GZC_ExplosiveBarrel', duration);
		}
		
		activated = true;
	}

	override void init()
	{
		eventname = "Barrels o' fun";
		duration = 35 * 10;
		type = E_Timed;
	}
}

Class GZC_OneTicMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			if (mo.tics > 1) mo.tics = 1;
		}
	}

	override void init()
	{
		eventname = "SV_Fastmonsters 1";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_FastMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			mo.bAlwaysFast = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.bAlwaysFast = def.bAlwaysFast;
		}
	}

	override bool verify()
	{
		bool result = super.verify();
		
		bool fastmode = !!G_SkillPropertyInt(SKILLP_FastMonsters);
		
		if (!fastmode) return false;
		
		return result;
	}

	override void init()
	{
		eventname = "Nightmare Monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_NotTheBees : GZC_Event
{
	override void deathFunc(Actor mo)
	{
		if (!mo.bIsMonster) return;
		
		int amount = random(5, 15);
		
		for (int i = 0; i < amount; ++i)
		{
			let thebee = mo.A_DropItem("Bee");
			thebee.bNoGravity = true;
			thebee.bFloat = true;
			
			int rng = random(1, 360);
			thebee.vel.x = cos(rng) * 5;
			thebee.vel.y = sin(rng) * 5;
			
		}
	}
	
	override void init()
	{
		eventname = "Not the bees!";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_ShuffleMonsters : GZC_Event
{
	Array<Actor> monsters;
	
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.bNoTarget = true;
		
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		monsters.clear();
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			mo.target = null;
			monsters.push(mo);
		}
		
		for (int i = 0; i < monsters.size(); ++i)
		{
			int index_a = -1;
			int index_b = -1;
		
			while (index_a == index_b)
			{
				index_a = random(0, monsters.size() - 1);
				index_b = random(0, monsters.size() - 1);
			}
			
			vector3 pos_a = monsters[index_a].pos;
			vector3 pos_b = monsters[index_b].pos;
			
			monsters[index_a].setOrigin(pos_b, false);
			monsters[index_b].setOrigin(pos_a, false);
		}
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		player.bNoTarget = false;
	}
	
	override void init()
	{
		eventname = "Shuffle Monsters";
		duration = 35 * 5;
		type = E_Timed;
	}
}

Class GZC_NoMoreInfighting : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			mo.bNoInFighting = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = GetDefaultByType(mo.getClass());
			
			mo.bNoInFighting = def.bNoInFighting;
		}
	}
	
	override void init()
	{
		eventname = "No infighting";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_ExplosionOnDeath : GZC_Event
{
	override void deathFunc(Actor mo)
	{
		if (!mo.bIsMonster) return;
		
		let pos = mo.pos;
		pos.z += (mo.height / 2);
		let kaboomie = Actor.spawn('Kablooie', pos);
		kaboomie.target = mo;
	}
	
	override void init()
	{
		eventname = "Explosive Deaths";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class Kablooie : Actor
{
	default
	{
		-RocketTrail;
		+NoGravity;
		+OldRadiusDmg;
		+Missile;
	}

	States
	{
		Spawn:
			MISL B 4 Bright;
			MISL B 4 Bright
			{
				if (target) target.A_Explode();
			}
			MISL C 6 Bright;
			MISL D 4 Bright;
			stop;
	}
}

Class GZC_RussianDollEnemies : GZC_Event
{
	double scalefactor;

	override void deathFunc(Actor _mo)
	{
		if (!_mo.bIsMonster) return;
		if (_mo.scale.x <= 0.4) return;
		if (_mo.target is 'PlayerPawn')
		{
			let doll = _mo.A_DropItem(_mo.getClass());
			doll.scale.x = _mo.scale.x * scalefactor;
			doll.scale.y = _mo.scale.y * scalefactor;
			let def = getDefaultByType(_mo.getClass());
			doll.Health = int(double(def.health) * min(doll.scale.x, 1));
			doll.target = _mo.target;
			doll.angle = _mo.angle;
		}
	}
	
	override void init()
	{
		eventname = "Matryoshka";
		duration = 35 * 60 * 3;
		type = E_Timed;
		scalefactor = 0.75;
	}
}

/*Class GZC_TurretEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			if (mo.resolveState('Missile'))
			{
				if (mo.health <= 0) continue;
				if (mo.InStateSequence(mo.curState, mo.resolveState('Pain'))) continue;
				if (!mo.InStateSequence(mo.curState, mo.resolveState('Missile')))
				{
					mo.setStateLabel('Missile');
				}
			}
		}
	}
	override void init()
	{
		eventname = "Enemies stand their ground";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}*/

Class GZC_AggressiveMissileMore : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			mo.bMissileMore = true;
			mo.bMissileEvenMore = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			
			let def = GetDefaultByType(mo.getClass());
			
			mo.bMissileMore = def.bMissileMore;
			mo.bMissileEvenMore = def.bMissileEvenMore;
		}
	}

	override void init()
	{
		eventname = "Aggressive Enemies";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_YouveBeenStruck : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		
		FLineTraceData shot;
		player.LineTrace(player.angle, 512, 0, 0, 0, 0, 0, shot);
		
		let cybie = Actor.spawn("GZC_Cyberfuck", shot.hitlocation);
		cybie.target = player;
		cybie.A_FaceTarget();
	}

	override void init()
	{
		eventname = "Cyberfuck";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_BetaSkulls : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('LostSoul');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			morphActor(mo, 'GZC_BetaSkull');
		}
		
		activated = true;
	}
	
	override void spawnFunc(Actor mo)
	{
		if (mo.getClass() != 'LostSoul') return;
		
		morphActor(mo, 'GZC_BetaSkull');
	}

	override void init()
	{
		eventname = "Beta Lost Souls";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FullPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 256;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	override void init()
	{
		eventname = "Enemies always flinch";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_ZeroPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_ZeroPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 0;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	override void init()
	{
		eventname = "Enemies cannot flinch";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_FullPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_InverseFlyingRules : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = !def.bFloat;
				mo.bNoGravity = !def.bNoGravity;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = def.bFloat;
				mo.bNoGravity = def.bNoGravity;
			}
		}
	}

	override void init()
	{
		eventname = "Inverted flying rules";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_AllMonstersWakeUp : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.target = player;
				mo.lastheard = player;
				mo.bAmbush = false;
				mo.A_damageSelf(0);
			}
		}
	}

	override void init()
	{
		eventname = "All monsters wake up";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_ArachnotronGrowthSpurt : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "Arachnotron" && mo.health > 0)
			{
				let momma = Actor.spawn("SpiderMastermind", mo.pos);
				momma.health = mo.health;
				momma.bMap07Boss2 = true;
				mo.destroy();
			}
		}
	}

	override void init()
	{
		eventname = "Arachnotron Growth Spurt";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_CacodemonHitscanners : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		if (mo is "CacodemonBall")
		{
			let owner = mo.target;
			
			owner.A_FaceTarget();
			owner.A_CustomBulletAttack(22.5, 0, 3, random(1,5) * 3, "BulletPuff", 0, CBAF_NORANDOM);
			owner.A_StartSound("shotguy/attack", CHAN_WEAPON);
			
			mo.Destroy();
		}
	}
	
	override void init()
	{
		eventname = "Shotgun Cacodemons";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FrictionlessEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bNoFriction = true;
				mo.bPushable = true;
				mo.bSlidesOnWalls = true;
				mo.pushFactor = 0.9;
			}	
		}
	}
		
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bNoFriction = def.bNoFriction;
				mo.bPushable = def.bPushable;
				mo.bSlidesOnWalls = def.bSlidesOnWalls;
				mo.pushFactor = def.pushFactor;
			}
		}
	}
	
	override void init()
	{
		eventname = "Enemies have no friction";
		duration = (35 * 60 * 2) + (35 * 30);
		type = E_Timed;
	}
}

Class GZC_AnkleBiterEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.scale.x /= 3;
				mo.scale.y /= 3;
				mo.A_SetSize(mo.height / 3, mo.radius / 3, false);
			}
		}
		
		activated = true;
	}
	
	override void closeFunc() 
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.scale.x = def.scale.x;
				mo.scale.y = def.scale.y;
				mo.A_SetSize(def.radius, def.height, false);
			}
		}
	}

	override void init()
	{
		eventname = "Ankle Biters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_StatueEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bPushable = true;
				mo.bShootable = false;
				mo.pushFactor = 0.9;
				mo.tics = -1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
				
				mo.bPushable = def.bPushable;
				mo.bShootable = def.bShootable;
				mo.pushFactor = def.pushFactor;
				mo.tics = 1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = false;
	}
	
	override void init()
	{
		eventname = "Statue enemies";
		duration = 35 * 30;
		type = E_Timed;
	}
}

Class GZC_NightmareMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (!mo.bIsMonster) continue;
		
			mo.bStealth = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			let def = GetDefaultByType(mo.getClass());
		
			if (!def.bStealth)
			{
				mo.bStealth = def.bStealth;
				mo.A_SetRenderStyle(def.Alpha, mo.getRenderStyle());
			}
		}
	}
	
	override void init()
	{
		eventname = "Stealth Monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_NightmareRespawns : GZC_Event
{

	override bool verify()
	{
		bool result = Super.verify();
		
		if (G_SkillPropertyInt(SKILLP_ACSReturn) == 4) return false;
		
		return result;
	}
	
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bAlwaysRespawn = true;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bAlwaysRespawn = def.bAlwaysRespawn;
			}
		}
	}
	
	override void init()
	{
		eventname = "Respawning monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_SpawnGreatGodImp : GZC_Event
{
	Array<DoomImp> imps;
	
	override bool verify()
	{
		bool result = super.verify();
		
		ThinkerIterator it = ThinkerIterator.create('DoomImp');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.health <= 0) continue;
			if (mo.getClassName() == 'DoomImp') return result;
		}
		
		return false;
	}

	override void eventFunc()
	{
		imps.clear();
	
		ThinkerIterator it = ThinkerIterator.create('DoomImp');
		Actor mo;
		
		while (mo = DoomImp(it.next())) imps.push(DoomImp(mo));
		
		if (imps.Size() == 0) return;
		
		int rng = random(0, imps.Size() - 1);
		imps[rng].A_Morph('GZC_GreatGodImp', duration);
		
		activated = true;
	}
	
	override void init()
	{
		eventname = "The Great God Imp";
		duration = 35 * 60;
		deleteme = true;
		type = E_Timed;
	}
}