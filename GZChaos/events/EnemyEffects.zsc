Class GZC_YouveBeenStruck : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		
		FLineTraceData shot;
		player.LineTrace(player.angle, 512, 0, 0, 0, 0, 0, shot);
		
		let cybie = Actor.spawn("GZC_Cyberfuck", shot.hitlocation);
		cybie.target = player;
		cybie.A_FaceTarget();
	}

	override void init()
	{
		eventname = "Cyberfuck";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_BetaSkulls : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!(mo is "LostSoul")) continue;
			
			Actor.spawn('GZC_BetaSkull', mo.pos);
			mo.destroy();
		}
	}
	
	override void spawnFunc(Actor mo)
	{
		if (mo.getClass() != 'LostSoul') return;
		
		Actor.spawn('GZC_BetaSkull', mo.pos);
		mo.destroy();
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (!(mo is "GZC_BetaSkull")) continue;
			
			if (mo.health > 0) Actor.spawn('LostSoul', mo.pos);
			mo.destroy();
		}
	}

	override void init()
	{
		eventname = "Beta Lost Souls";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FullPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 256;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	override void init()
	{
		eventname = "Enemies always flinch";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_ZeroPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_ZeroPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 0;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	override void init()
	{
		eventname = "Enemies cannot flinch";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_FullPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_InverseFlyingRules : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = !def.bFloat;
				mo.bNoGravity = !def.bNoGravity;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = def.bFloat;
				mo.bNoGravity = def.bNoGravity;
			}
		}
	}

	override void init()
	{
		eventname = "Inverted flying rules";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_AllMonstersWakeUp : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.target = player;
				mo.lastheard = player;
				mo.bAmbush = false;
				mo.A_damageSelf(0);
			}
		}
	}

	override void init()
	{
		eventname = "All monsters wake up";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_ArachnotronGrowthSpurt : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "Arachnotron" && mo.health > 0)
			{
				let momma = Actor.spawn("SpiderMastermind", mo.pos);
				momma.health = mo.health;
				momma.bMap07Boss2 = true;
				mo.destroy();
			}
		}
	}

	override void init()
	{
		eventname = "Arachnotron Growth Spurt";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_CacodemonHitscanners : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		if (mo is "CacodemonBall")
		{
			let owner = mo.target;
			
			owner.A_FaceTarget();
			owner.A_CustomBulletAttack(22.5, 0, 3, random(1,5) * 3, "BulletPuff", 0, CBAF_NORANDOM);
			owner.A_StartSound("shotguy/attack", CHAN_WEAPON);
			
			mo.Destroy();
		}
	}
	
	override void init()
	{
		eventname = "Shotgun Cacodemons";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FrictionlessEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bNoFriction = true;
				mo.bPushable = true;
				mo.bSlidesOnWalls = true;
				mo.pushFactor = 0.9;
			}	
		}
	}
		
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bNoFriction = def.bNoFriction;
				mo.bPushable = def.bPushable;
				mo.bSlidesOnWalls = def.bSlidesOnWalls;
				mo.pushFactor = def.pushFactor;
			}
		}
	}
	
	override void init()
	{
		eventname = "Enemies have no friction";
		duration = (35 * 60 * 2) + (35 * 30);
		type = E_Timed;
	}
}

Class GZC_AnkleBiterEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.scale.x /= 3;
				mo.scale.y /= 3;
				mo.A_SetSize(mo.height / 3, mo.radius / 3, false);
			}
		}
		
		activated = true;
	}
	
	override void closeFunc() 
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.scale.x = def.scale.x;
				mo.scale.y = def.scale.y;
				mo.A_SetSize(def.radius, def.height, false);
			}
		}
	}

	override void init()
	{
		eventname = "Ankle Biters";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_StatueEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bPushable = true;
				mo.bShootable = false;
				mo.pushFactor = 0.9;
				mo.tics = -1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
				
				mo.bPushable = def.bPushable;
				mo.bShootable = def.bShootable;
				mo.pushFactor = def.pushFactor;
				mo.tics = 1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = false;
	}
	
	override void init()
	{
		eventname = "Statue enemies";
		duration = 35 * 30;
		type = E_Timed;
	}
}

Class GZC_NightmareMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (!mo.bIsMonster) continue;
		
			mo.bStealth = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			let def = GetDefaultByType(mo.getClass());
		
			if (!def.bStealth)
			{
				mo.bStealth = def.bStealth;
				mo.A_SetRenderStyle(def.Alpha, mo.getRenderStyle());
			}
		}
	}
	
	override void init()
	{
		eventname = "Stealth Monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_NightmareRespawns : GZC_Event
{

	override bool verify()
	{
		bool result = Super.verify();
		
		if (G_SkillPropertyInt(SKILLP_ACSReturn) == 4) return false;
		
		return result;
	}
	
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bAlwaysRespawn = true;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bAlwaysRespawn = def.bAlwaysRespawn;
			}
		}
	}
	
	override void init()
	{
		eventname = "Respawning monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_SpawnGreatGodImp : GZC_Event
{
	Actor impy;

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
	
		while (true)
		{
			int rng = random(0, level.Sectors.size() - 1);
			let c = level.Sectors[rng].centerspot;
			if (level.IsPointInLevel((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c))))
			{
				double ceilheight = level.Sectors[rng].ceilingplane.ZAtPoint(c);
				double floorheight = level.Sectors[rng].floorplane.ZAtPoint(c);
				if (ceilheight - floorheight > 64)
				{
					impy = Actor.spawn('greatgodimp', (c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c)));
					impy.target = player;
					impy.A_damageSelf(0);
					activated = true;
					break;
				}
			}
		}
	}
	
	override void closeFunc() 
	{
		if (impy) impy.destroy();
	}
	
	override void init()
	{
		eventname = "The Great God Imp";
		duration = 35 * 60;
		deleteme = true;
		type = E_Timed;
	}
}