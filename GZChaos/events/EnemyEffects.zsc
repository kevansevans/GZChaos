Class GZC_BetaSkulls : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!(mo is "LostSoul")) continue;
			
			Actor.spawn('GZC_BetaSkull', mo.pos);
			mo.destroy();
		}
	}
	
	override void spawnFunc(Actor mo)
	{
		if (mo.getClass() != 'LostSoul') return;
		
		Actor.spawn('GZC_BetaSkull', mo.pos);
		mo.destroy();
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (!(mo is "GZC_BetaSkull")) continue;
			
			if (mo.health > 0) Actor.spawn('LostSoul', mo.pos);
			mo.destroy();
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_BetaSkulls');
		event.eventname = "Beta Lost Souls";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FullPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 256;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FullPainChances');
		event.eventname = "Enemies always flinch";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_ZeroPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_ZeroPainChances : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.painChance = 0;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.painChance = def.painChance;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_ZeroPainChances');
		event.eventname = "Enemies cannot flinch";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
	
	override bool verify()
	{
		bool result = super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is 'GZC_FullPainChances') return false;
		}
		
		return result;
	}
}

Class GZC_InverseFlyingRules : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = !def.bFloat;
				mo.bNoGravity = !def.bNoGravity;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
	
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				let def = getDefaultByType(mo.getClass());
				mo.bFloat = def.bFloat;
				mo.bNoGravity = def.bNoGravity;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_InverseFlyingRules');
		event.eventname = "Inverted flying rules";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_AllMonstersWakeUp : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster)
			{
				mo.target = player;
				mo.lastheard = player;
				mo.bAmbush = false;
				mo.A_damageSelf(0);
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_AllMonstersWakeUp');
		event.eventname = "All monsters wake up";
		event.duration = 35 * 60;
		event.type = E_Instant;
		return event;
	}
}

Class GZC_ArachnotronGrowthSpurt : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "Arachnotron" && mo.health > 0)
			{
				let momma = Actor.spawn("SpiderMastermind", mo.pos);
				momma.health = mo.health;
				momma.bMap07Boss2 = true;
				mo.destroy();
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_ArachnotronGrowthSpurt');
		event.eventname = "Arachnotron Growth Spurt";
		event.duration = 35 * 60;
		event.type = E_Instant;
		return event;
	}
}

Class GZC_CacodemonHitscanners : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		if (mo is "CacodemonBall")
		{
			let owner = mo.target;
			
			owner.A_FaceTarget();
			owner.A_CustomBulletAttack(22.5, 0, 3, random(1,5) * 3, "BulletPuff", 0, CBAF_NORANDOM);
			owner.A_StartSound("shotguy/attack", CHAN_WEAPON);
			
			mo.Destroy();
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_CacodemonHitscanners');
		event.eventname = "Shotgun Cacodemons";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FrictionlessEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bNoFriction = true;
				mo.bPushable = true;
				mo.bSlidesOnWalls = true;
				mo.pushFactor = 0.9;
			}	
		}
	}
		
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bNoFriction = def.bNoFriction;
				mo.bPushable = def.bPushable;
				mo.bSlidesOnWalls = def.bSlidesOnWalls;
				mo.pushFactor = def.pushFactor;
			}
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FrictionlessEnemies');
		event.eventname = "Enemies have no friction";
		event.duration = (35 * 60 * 2) + (35 * 30);
		event.type = E_Timed;
		return event;
	}
}

Class GZC_AnkleBiterEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.scale.x /= 3;
				mo.scale.y /= 3;
				mo.A_SetSize(mo.height / 3, mo.radius / 3, false);
			}
		}
		
		activated = true;
	}
	
	override void closeFunc() 
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.scale.x = def.scale.x;
				mo.scale.y = def.scale.y;
				mo.A_SetSize(def.radius, def.height, false);
			}
		}
	}

	static GZC_Event create()
	{
		GZC_Event event = new('GZC_AnkleBiterEnemies');
		event.eventname = "Ankle Biters";
		event.duration = 35 * 60 * 2;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_StatueEnemies : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bPushable = true;
				mo.bShootable = false;
				mo.pushFactor = 0.9;
				mo.tics = -1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
				
				mo.bPushable = def.bPushable;
				mo.bShootable = def.bShootable;
				mo.pushFactor = def.pushFactor;
				mo.tics = 1;
			}
		}
		
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoTarget = false;
	}
	
	static GZC_Event create()
	{
		GZC_Event event = new('GZC_StatueEnemies');
		event.eventname = "Statue enemies";
		event.duration = 35 * 30;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_NightmareMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			mo.bStealth = true;
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			let def = GetDefaultByType(mo.getClass());
		
			if (!def.bStealth)
			{
				mo.bStealth = def.bStealth;
				mo.A_SetRenderStyle(def.Alpha, mo.getRenderStyle());
			}
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_NightmareMonsters');
		event.eventname = "Stealth Monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_NightmareRespawns : GZC_Event
{

	override bool verify()
	{
		bool result = Super.verify();
		
		if (G_SkillPropertyInt(SKILLP_ACSReturn) == 4) return false;
		
		return result;
	}
	
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				mo.bAlwaysRespawn = true;
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
	
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bIsMonster)
			{
				let def = GetDefaultByType(mo.getClass());
			
				mo.bAlwaysRespawn = def.bAlwaysRespawn;
			}
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_NightmareRespawns');
		event.eventname = "Respawning monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_SpawnGreatGodImp : GZC_Event
{
	Actor impy;

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
	
		while (true)
		{
			int rng = random(0, level.Sectors.size() - 1);
			let c = level.Sectors[rng].centerspot;
			if (level.IsPointInLevel((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c))))
			{
				double ceilheight = level.Sectors[rng].ceilingplane.ZAtPoint(c);
				double floorheight = level.Sectors[rng].floorplane.ZAtPoint(c);
				if (ceilheight - floorheight > 64)
				{
					impy = Actor.spawn('greatgodimp', (c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c)));
					impy.target = player;
					impy.A_damageSelf(0);
					activated = true;
					break;
				}
			}
		}
	}
	
	override void closeFunc() 
	{
		if (impy) impy.destroy();
	}
	
	static GZC_Event create()
	{
		GZC_Event event = new('GZC_SpawnGreatGodImp');
		event.eventname = "The Great God Imp";
		event.duration = 35 * 60;
		event.type = E_Timed;
		return event;
	}
}