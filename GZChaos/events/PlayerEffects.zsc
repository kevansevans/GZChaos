Class GZC_Regeneration : GZC_Event
{
	override void eventFunc()
	{
		if (gametic % (35 * 3) != 0) return;
		
		let player = players[consoleplayer].mo;
		player.GiveBody(random(1, 5), 100);
	}

	override void init()
	{
		eventname = "Health Regeneration";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_ShootingNotAllowed : GZC_Event
{
	override void eventFunc()
	{
		let pinfo = players[consoleplayer];
		if (!pinfo.readyWeapon.ammo1 && !pinfo.readyWeapon.ammo2) return;
		if (pinfo.buttons & (BT_ATTACK | BT_ALTATTACK))
		{
			pinfo.mo.A_DamageSelf(0x1);
		}
	}
	
	override void init()
	{
		eventname = "No Shooting Allowed";
		duration = 35 * 5;
		type = E_Timed;
	}
}

Class GZC_GyroscopicCamera : GZC_Event
{
	override void eventFunc()
	{
		if (gametic % 35 == 0)
		{
			let player = players[consoleplayer].mo;
			player.A_SetRoll(player.roll += 0.004);
		}
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		player.A_SetRoll(0);
	}
	
	override void init()
	{
		eventname = "Gyroscopic camera roll";
		duration = 35 * 60 * 60;
		type = E_Timed;
	}
}

Class GZC_PlayerIsAGhost : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.bThruActors = true;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		player.bThruActors = false;
	}
	
	override void init()
	{
		eventname = "Walk through actors";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_NotQuiteInvulnerability : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.GiveBody(999, 999);
		activated = true;
	}

	override void init()
	{
		eventname = "Not quite invulnerability...";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_EarthquakeMode : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.A_Quake(9, 9, 0, 5, "");
	}

	override void init()
	{
		eventname = "Earthquake!";
		duration = 35 * 60;
		type = E_Timed;
	}
}

/*Class GZC_PainRave : GZC_Event
{
	//Save for some day
	override void EventFunc()
	{
		let player = players[consoleplayer];
		
		player.mo.DamageFade = 0x00CC00;
		//player.DamageCount = Clamp(player.damagecount, 0, 12);
	}

	override void init()
	{
		eventname = "Pain Rave";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}*/

Class GZC_AggressiveWeaponBobbing : GZC_Event
{
	override void EventFunc()
	{
		let player = players[consoleplayer].mo;
		
		player.viewbob = (10.0 * sin(gametic)) + (5.0 * cos(gametic));
		player.player.weaponstate |= WF_WeaponBobbing;
	}
	
	override void CloseFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.viewbob = def.viewbob;
		player.player.weaponstate &= ~(WF_WeaponBobbing);
	}

	override void init()
	{
		eventname = "Whacky Wavey Inflatable Doomguy";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_DoomThreeNightmare : GZC_Event
{
	override void eventFunc()
	{
		if (gametic % (35 * 5) != 0) return;
		
		let player = players[consoleplayer].mo;
		
		if (player.health <= 25) return;
		
		int drain = min(player.health - 25, 5);
		player.A_DamageSelf(drain, 'Melee');
		player.A_StartSound("Doom3/TakeHealth", CHAN_AUTO);
	}
	
	override void init()
	{
		eventname = "Doom 3 Nightmare";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_Aimbot : GZC_Event
{
	double distance;
	Actor closest;
	
	override void eventFunc()
	{
		distance = 0x7FFFFFFF;
		closest = null;
		
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		let player = players[consoleplayer].mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bIsMonster) continue;
			if (mo is "Inventory") continue;
			if (mo.health <= 0) continue;
			if (!player.isVisible(mo, true)) continue;
			
			double dist = player.distance3D(mo);
			if (dist < distance)
			{
				distance = dist;
				closest = mo;
			}
		}
		
		if (!closest) return;
		
		player.angle = atan2(closest.pos.y - player.pos.y, closest.pos.x - player.pos.x);
		if (!player.player.centering) player.pitch = PitchTo(player, closest, 0.6);
	}
	
	double PitchTo( Actor a, Actor b, double hfact = 1. )
    {
        if ( !a || !b ) return 0;
        Vector3 thispos = a.player?a.Vec2OffsetZ(0,0,a.player.viewz):a.Vec3Offset(0,0,a.missileheight);
        Vector3 otherpos = b.Vec3Offset(0,0,b.height*hfact);
        Vector3 diff = level.Vec3Diff(thispos,otherpos);
        double dist = diff.length();
        if ( dist > 0 ) return -asin(diff.z/dist);
        return 0;
    }
	
	override void init()
	{
		eventname = "Aimbot";
		duration = 35 * 90;
		type = E_Timed;
	}
}

Class GZC_ReducedFieldOfView : GZC_Event
{
	override void eventFunc()
	{
		let inf = players[consoleplayer];
		
		inf.FOV = 30;
	}
	
	override void closeFunc()
	{
		players[consoleplayer].FOV = players[consoleplayer].desiredFOV;
	}
	
	override void init()
	{
		eventname = "Reduced FOV";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_QuakeFOV : GZC_Event
{
	override void eventFunc()
	{
		let inf = players[consoleplayer];
		
		inf.FOV = 150;
	}
	
	override void closeFunc()
	{
		players[consoleplayer].FOV = players[consoleplayer].desiredFOV;
	}
	
	override void init()
	{
		eventname = "Quake PRO";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_ThirdPerson : GZC_Event
{
	override void eventFunc()
	{
		players[consoleplayer].cheats |= CF_ChaseCam;
	}
	
	override void closeFunc()
	{
		players[consoleplayer].cheats &= ~(CF_ChaseCam);
	}
	
	override void init()
	{
		eventname = "Chase Cam";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_DrowsyDooming : GZC_Event
{
	int prevHealth;
	double tiredness;
	
	override void eventFunc()
	{
		GZC_Drowsy(EventHandler.find('GZC_Drowsy')).enabled = true;
	
		if (gametic % 3 == 0) ++tiredness;
	
		let player = players[consoleplayer].mo;
		
		if (player.health < prevHealth) tiredness = 0;
		
		prevHealth = player.health;
		
		if (player.curstate == player.resolveState('Missile')) tiredness -= 10;
		if (player.curstate == player.resolveState('Melee')) tiredness -= 10;
		
		tiredness = max(0, tiredness);
		
		GZC_Drowsy(EventHandler.find('GZC_Drowsy')).tiredness = tiredness;
	}
	
	override void closeFunc()
	{
		GZC_Drowsy(EventHandler.find('GZC_Drowsy')).tiredness = 0;
		GZC_Drowsy(EventHandler.find('GZC_Drowsy')).enabled = false;
	}
	
	override void init()
	{
		eventname = "Drowsy Dooming";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

/*Class GZC_CoffeeBreak : GZC_Event
{
	String lastweapon;

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.A_Morph('CoffeePlayer', 0x7FFFFFFF, 0, 'Actor', 'Actor');
		activated = true;
	}
	
	override void closeFunc()
	{
		
	}

	override void init()
	{
		eventname = "Coffee break";
		duration = 35 * 60 * 90;
		deleteme = true;
		type = E_HiddenTimer;
	}
}*/

Class GZC_ShrunkTheDoomguy : GZC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		player.A_SetSize(player.radius * 0.1, player.height * 0.1);
		player.viewHeight *= 0.1;
		player.player.viewHeight *= 0.01;
		player.forwardMove1 *= 0.1;
		player.forwardMove2 *= 0.1;
		player.sideMove1 *= 0.1;
		player.sideMove2 *= 0.1;
		player.MaxStepHeight *= 0.1;
		player.ViewBob *= 0.1;
		player.scale.x *= 0.1;
		player.scale.y *= 0.1;
		
		activated = true;
	}
	
	override void closeFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		let def = GetDefaultByType(player.getClass());
		player.A_SetSize(def.radius, def.height);
		player.viewHeight = def.viewHeight;
		player.player.viewHeight = def.viewHeight;
		player.forwardMove1 = def.forwardMove1;
		player.forwardMove2 = def.forwardMove2;
		player.sideMove1 = def.sideMove1;
		player.sideMove2 = def.sideMove2;
		player.MaxStepHeight = def.MaxStepHeight;
		player.viewBob = def.viewBob;
		player.scale.x = def.scale.x;
		player.scale.y = def.scale.y;
	}

	override void init()
	{
		GZC_Event event = new('GZC_ShrunkTheDoomguy');
		eventname = "Honey, I shrunk the Doomguy!";
		duration = 35 * 60 * 3;
		type = E_Timed;

	}
}

Class GZC_MorphEffect : GZC_Event
{}

Class GZC_MorphIntoDog : GZC_MorphEffect
{
	Class<Actor> original;

	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		player.A_Morph('DogPlayer', duration);
		
		activated = true;
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		GZC_Event event = new('GZC_MorphIntoDog');
		eventname = "Dog mode!";
		duration = 35 * 60 * 2;
		type = E_Timed;
		deleteMe = true;

	}
}

Class GZC_MorphIntoChicken : GZC_MorphEffect
{
	Class<Actor> original;

	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		player.A_Morph('ChickenPlayer', duration);
		
		activated = true;
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		eventname = "cockadoodledoo!";
		duration = 35 * 60 * 2;
		type = E_Timed;
		deleteMe = true;
	}
}

Class GZC_DoubleRunning : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.forwardMove1 = def.forwardMove1 * 4;
		player.forwardMove2 = def.forwardMove2 * 2;
		player.sideMove1 = def.sideMove1 * 4;
		player.sideMove2 = def.sideMove2 * 2;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.forwardMove1 = def.forwardMove1;
		player.forwardMove2 = def.forwardMove2;
		player.sideMove1 = def.sideMove1;
		player.sideMove2 = def.sideMove2;
	}

	override void init()
	{
		eventname = "Give it the gas!";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_DisableRunning : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.forwardMove2 = def.forwardMove2 / 2;
		player.sideMove2 = def.sideMove2 / 2;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.forwardMove2 = def.forwardMove2;
		player.sideMove2 = def.sideMove2;
	}

	override void init()
	{
		eventname = "No need to rush";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_StartRecording : GZC_Event
{
	//stupid gzdoom not letting me use vector3's in an array
	Array<Double> posx;
	Array<Double> posy;
	Array<Double> posz;
	Array<Double> angles;
	
	int st;

	override void eventFunc()
	{
		if (!posx.size())
		{
			posx.clear();
			posy.clear();
			posz.clear();
			angles.clear();
			st = 0;
		}
		
		PlayerPawn player = players[consoleplayer].mo;
		
		switch (st)
		{
			case 0:
			
				Vector3 checkpoint = player.pos;
				Double checkangle = player.angle;
				
				posx.push(checkpoint.x);
				posy.push(checkpoint.y);
				posz.push(checkpoint.z);
				
				angles.push(checkangle);
				
				if (life == duration - 1)
				{
					st = 1;
					life = 0;
					eventname = "<< Rewinding";
				}
				break;
			case 1:
			
				int index = posx.size() - 1;
				
				player.setOrigin((posx[index], posy[index], posz[index]), true);
				player.angle = angles[index];
				
				posx.delete(index);
				posy.delete(index);
				posz.delete(index);
				
				angles.delete(index);
				
				posx.shrinkToFit();
				posy.shrinkToFit();
				posz.shrinkToFit();
				
				angles.shrinkToFit();
				
				break;
		}
	}
		
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		eventname = "Recording";
		duration = 35 * 15;
		type = E_Timed;
		deleteme = true;
	}
}

Class GZC_ScardeyItems : GZC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo is "Inventory")
			{
				if (player.distance3D(mo) < 256)
				{
					mo.bSlidesOnWalls = true;
					mo.bNoBlockMonst = true;
					mo.thrust(15, player.angleTo(mo));
				}
			}
		}
	}
	
	override void closeFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
	}
	
	override void init()
	{
		GZC_Event event = new('GZC_ScardeyItems');
		eventname = "Pickups are scared of player";
		duration = 35 * 60 * 2;
		type = E_Timed;

	}
}

Class GZC_RightJoyconDrift : GZC_Event
{
	double drift;
	double angle;
	
	override void eventFunc()
	{
		PlayerInfo player = players[consoleplayer];
		double xspeed = cos(angle) * drift;
		double yspeed = sin(angle) * drift;
		
		if (player.cmd.pitch == 0 && player.cmd.yaw == 0)
		{
			player.mo.angle += (xspeed / 1000);
			if (!player.centering) player.mo.pitch += (yspeed / 1000);
		
			player.mo.CheckPitch();
		}
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		drift = random(400, 600);
		angle = random(0, 359);
		eventname = "Right Joycon drift";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_LeftJoyconDrift : GZC_Event
{
	double drift;
	double angle;
	
	override void eventFunc()
	{
		PlayerInfo player = players[consoleplayer];
		double xspeed = cos(angle) * drift;
		
		if (player.cmd.forwardmove == 0 && player.cmd.sidemove == 0)
		{
			player.mo.thrust(xspeed / 2000, (xspeed / 2000) + player.mo.angle);
		}
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		drift = random(400, 600);
		angle = random(0, 359);
		eventname = "Left Joycon drift";
		duration = 35 * 60 * 2;
		type = E_Timed;
	}
}

Class GZC_DisableForwardBackwards : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_DisableStrafingMovement") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.forwardMove1 = player.forwardMove2 = 0;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.forwardMove1 = def.ForwardMove1;
		player.forwardMove2 = def.ForwardMove2;
	}
	
	override void init()
	{
		eventname = "Disable Forward/Backwards movement";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_DisableStrafingMovement : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_DisableForwardBackwards") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.sideMove1 = player.sideMove2 = 0;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());
		
		player.sideMove1 = def.sideMove1;
		player.sideMove2 = def.sideMove2;
	}
	
	override void init()
	{
		eventname = "Disable strafing movement";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_InvertPlayerMovement : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());

		player.forwardMove1 = def.forwardMove1 * -1;
		player.forwardMove2 = def.forwardMove2 * -1;
		player.sideMove1 = def.sideMove1 * -1;
		player.sideMove2 = def.sideMove2 * -1;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		let def = getDefaultByType(player.getClass());

		player.forwardMove1 = def.forwardMove1;
		player.forwardMove2 = def.forwardMove2;
		player.sideMove1 = def.sideMove1;
		player.sideMove2 = def.sideMove2;
	}
	
	override void init()
	{
		eventname = "Inverted movement";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_GameEndPlayer : GZC_Event
{
	int startframe;
	bool screm;

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		if (!screm)
		{
			player.A_PlayerScream();
			screm = true;
		}
		if (gametic - startframe >= 35 * 1)
		{
			player.A_Explode(999, 64);
			activated = true;
		}
		else
		{
			Player.A_SetMugshotState("Ouch");
		}
	}
	
	override bool verify()
	{
		bool result = Super.verify();
	
		let player = players[consoleplayer];
		if (Cvar.getCvar("GZC_UseSeed", player).getBool()) return false;
		
		return result;
	}

	override void init()
	{
		startframe = gametic;
		eventname = "Player commits suicide";
		duration = 35 * 90;
		type = E_HiddenTimer;
	}
}

Class GZC_FakeGameEndPlayer : GZC_Event
{
	int startframe;
	bool screm;

	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		if (!screm)
		{
			player.A_PlayerScream();
			screm = true;
		}
		if (gametic - startframe <= 35 * 1)
		{
			Player.A_SetMugshotState("Ouch");
		}
		else if (gametic - startframe >= 35 * 3)
		{
			eventname = "Fake suicide :)";
			activated = true;
		}
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		startframe = gametic;
		eventname = "Player commits suicide";
		duration = 35 * 90;
		type = E_HiddenTimer;
	}
}

Class GZC_CantStopFiring : GZC_Event
{
	override void eventFunc()
	{
		PlayerInfo player = players[consoleplayer];
		player.cmd.buttons |= (BT_ATTACK | BT_ALTATTACK);
		player.mo.checkWeaponFire();
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		eventname = "Can't stop shooting!";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_SuperIcePhysics : GZC_Event
{
	override void eventFunc()
	{
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoFriction = true;
	}
	
	override void closeFunc()
	{
		PlayerInfo player = players[consoleplayer];
		player.mo.bNoFriction = false;
	}
	
	override void init()
	{
		eventname = "Disabled player friction";
		duration = (35 * 60 * 2) + (35 * 30);
		type = E_Timed;
	}
}

Class GZC_FallDamage : GZC_Event
{
	override void eventFUnc()
	{
		PlayerInfo player = players[consoleplayer];
		player.mo.bFallDamage = true;
	}
	
	override void closeFunc()
	{
		PlayerInfo player = players[consoleplayer];
		player.mo.bFallDamage = false;
	}
	
	override void init()
	{
		eventname = "Player takes fall damage";
		duration = (35 * 60 * 2) + (35 * 30);
		type = E_Timed;
	}
}

Class GZC_TeleportPlayer : GZC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		while (true)
		{
			int rng = random(0, level.Sectors.size() - 1);
			let c = level.Sectors[rng].centerspot;
			if (level.IsPointInLevel((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c))))
			{
				double ceilheight = level.Sectors[rng].ceilingplane.ZAtPoint(c);
				double floorheight = level.Sectors[rng].floorplane.ZAtPoint(c);
				if (ceilheight - floorheight > 64)
				{
					player.teleport((c.x, c.y, level.Sectors[rng].floorplane.ZAtPoint(c)), player.angle, 1);
					break;
				}
			}
		}
	}
	
	override void init()
	{
		eventname = "Teleport to random sector";
		duration = 35 * 90;
		type = E_Instant;
	}
}