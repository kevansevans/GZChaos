Class GZC_CompanionImpEvent : GZC_Event
{
	override void EventFunc()
	{
		activated = true;
		
		let player = players[consoleplayer].mo;
		Actor.spawn('GZC_CompanionImp', player.pos);
	}
	
	override void init()
	{
		eventname = "Companion Imp";
		duration = 35 * 60;
		type = E_Instant;
		deleteme = true;
	}
}

Class GZC_CompanionImp : DoomImp
{
	Default
	{
		Translation "CompanionImp";
		+Friendly;
	}
	
	override void tick()
	{
		Super.tick();
		
		if (gametic % (35 * 10) != 0) return;
		
		let player = players[consoleplayer].mo;
		if (self.distance3D(player) > 1024 || !(player.isVisible(self, true) && self.isVisible(player, true)))
		{
			Self.SetOrigin(player.pos, false);
			Actor.spawn('TeleportFog', player.pos);
		}
	}
	
	States
	{
		Melee:
		Missile:
			TNT1 A 0;
			Goto See;
	}
}

Class GZC_BouncyProjectiles : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create('Actor');
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bMissile) continue;
			
			setBounceOnActor(mo);
		}
	}
	
	override void spawnFunc(Actor mo)
	{
		if (!mo.bMissile)
		{
			setBounceOnActor(mo);
		}
	}
	
	void setBounceOnActor(Actor mo)
	{
		mo.bBounceOnWalls = true;
		mo.bBounceOnFloors = true;
		mo.bBounceOnCeilings = true;
		mo.bAllowBounceOnActors = true;
		mo.BounceFactor = 1.0;
		mo.WallBounceFactor = 1.0;
		mo.BounceSound = "bounce/boing";
	}

	override void init()
	{
		eventname = "Bouncy! Bouncy! Bouncy!"; //Insyncopated style!
		duration = 35 * 60 * 4;
		type = E_Timed;
		deleteme = true;
	}
}

Class GZC_RoomClearEvent : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
		
		if (level.Killed_Monsters >= level.Total_Monsters) return false;
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_RoomClearEvent") return false;
		}
		
		return result;
	}
}

Class GZC_JitterSkull : GZC_RoomClearEvent
{
	Array<ActorTracker> pointers;
	Actor Jitter;
	
	String levelmus;
	
	override void eventFunc()
	{
		if (pointers.size() == 0)
		{
			pointers.clear();
		
			levelmus = level.music;
		
			ThinkerIterator it = ThinkerIterator.create("Actor");
			Actor mo;
		
			while (mo = Actor(it.next()))
			{
				if (mo is "EmptyActor") continue;
				if (!mo.bIsMonster) continue;
				if (mo.health <= 0) continue;
				
				let tracker = ActorTracker(Actor.spawn("ActorTracker", (0, 0, 0)));
				tracker.type = mo.getClass();
				tracker.pos = mo.pos;
				pointers.push(tracker);
				morphActor(mo, "EmptyActor");
			}
			
			let player = players[consoleplayer].mo;
			player.S_ChangeMusic("");
		}
		
		if (!Jitter) spawnJitterSkull();
	}
	
	void spawnJitterSkull()
	{
		if (Jitter) return;
		
		Jitter = Actor.spawn('JitterSkull', (0,0,0));
		let player = players[consoleplayer].mo;
		
		while (true)
		{
			int place = random(0, pointers.size() - 1);
			Vector3 pos = pointers[place].pos;
			Jitter.setOrigin(pos, false);
			if (Jitter.isVisible(player, true)) continue;
			Jitter.A_DamageSelf(0);
			break;
		}
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		player.S_ChangeMusic(levelmus);
		
		if (Jitter) Jitter.destroy();
	}
	
	override void init()
	{
		eventname = "The Ghoul's Forest";
		duration = 35 * 60;
		type = E_Timed;
		deleteme = true;
	}
}

Class GZC_ContainmentBreach : GZC_RoomClearEvent
{
	Array<ActorTracker> pointers;
	SCP173 scp;
	
	String levelmus;
	
	override void eventFunc()
	{
		pointers.clear();
		
		levelmus = level.music;
		
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "EmptyActor") continue;
			if (!mo.bIsMonster) continue;
			if (mo.health <= 0) continue;
			
			let tracker = ActorTracker(Actor.spawn("ActorTracker", (0, 0, 0)));
			tracker.type = mo.getClass();
			tracker.pos = mo.pos;
			pointers.push(tracker);
			
			morphActor(mo, "EmptyActor");
		}
		
		scp = SCP173(Actor.spawn('SCP173', (0,0,0)));
		let player = players[consoleplayer].mo;
		
		while (true)
		{
			int place = random(0, pointers.size() - 1);
			Vector3 pos = pointers[place].pos;
			scp.setOrigin(pos, false);
			if (scp.isVisible(player, true)) continue;
			break;
		}
		
		player.S_ChangeMusic("");
		
		activated = true;
	}
	
	override void closeFunc()
	{
		let player = players[consoleplayer].mo;
		player.S_ChangeMusic(levelmus);
		
		if (scp) scp.destroy();
	}
	
	override void init()
	{
		eventname = "Containment Breach";
		duration = 35 * 60 * 3;
		type = E_Timed;
		deleteme = true;
	}
}

Class GZC_ChaosDevice : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		Vector3 location;
		int face;
		[location, face] = level.pickPlayerStart(player.playerNumber());
		player.teleport(location, face, 1);
	}

	override void init()
	{
		eventname = "Chaos Device";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_ShuffleAmmoTypes : GZC_Event
{
	override void eventFunc()
	{
		Array<Class<Ammo> > types;
		
		PlayerPawn player = players[consoleplayer].mo;
		WeaponSlots weapons = players[consoleplayer].weapons;
		
		for (int slot = 0; slot < 10; ++slot)
		{
			int numWeaps = weapons.slotSize(slot);
			
			if (numWeaps == 0) continue;
			
			for (int index = 0; index < numWeaps; ++index)
			{
				Class<weapon> gun = weapons.getWeapon(slot, index);
				
				let def = getDefaultByType(gun);
				
				if (def.ammoType1) types.push(def.ammoType1);
				if (def.ammoType2) types.push(def.ammoType2);
			}
		}
		
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "weapon" && Inventory(mo).owner is "PlayerPawn")
			{
				let gun = Weapon(mo);
				
				if (gun.AmmoType1)
				{
					while (true)
					{
						let selected = types[random(0, types.size() - 1)];
						if (selected is gun.AmmoType1) continue;
						
						gun.AmmoType1 = (Class<Ammo>)(selected);
						gun.Ammo1 = Ammo(player.FindInventory(selected));
						
						break;
					}
				}
			
				if (gun.AmmoType2)
				{
					while (true)
					{
						let selected = types[random(0, types.size() - 1)];
						if (selected is gun.AmmoType2) continue;
					
						gun.AmmoType2 = (Class<Ammo>)(selected);
						gun.Ammo2 = Ammo(player.FindInventory(selected));
						break;
					}
				}
			}
		}
		
		activated = true;
	}
	
	override void closeFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "weapon" && Inventory(mo).owner is "PlayerPawn")
			{
				let gun = Weapon(mo);
				let def = getDefaultByType(gun.getClass());
				
				if (gun.ammoType1)
				{
					gun.ammoType1 = def.ammoType1;
					gun.ammo1 = Ammo(Player.findInventory(gun.ammoType1.getClassName()));
				}
				
				if (gun.ammoType2)
				{
					gun.ammoType2 = def.ammoType2;
					gun.ammo2 = Ammo(Player.findInventory(gun.ammoType2.getClassName()));
				}
			}
		}
	}

	override void init()
	{
		eventname = "Shuffled ammo pool";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_LimpProjectiles : GZC_Event
{
	override void spawnFunc(Actor mo)
	{
		if (mo.bMissile)
		{
			if (!(mo.target is "PlayerPawn"))
			{
				mo.bNoGravity = false;
			}
		}
	}

	override void init()
	{
		eventname = "Limp enemy projectiles";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_JupiterGravity : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_MoonGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(10);
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	override void init()
	{
		eventname = "Jupiter Gravity";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_MoonGravity : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_JupiterGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_LowGravity();
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	override void init()
	{
		eventname = "Moon Gravity";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FartingMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster && mo.health > 0)
			{
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % (35 * 2) == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	override void init()
	{
		eventname = "Farting Monsters";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FartingItems : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "inventory")
			{
				if (Inventory(mo).owner) continue;
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % (35 * 2) == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	override void init()
	{
		eventname = "Farting items";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_FartingPlayer : GZC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		double zfloor = player.getZAt();
		if (zfloor != player.pos.z) return;
		if ((gametic + random(0, 35)) % (35 * 2) == 0)
		{
			if (!random(0, 5)) return;
		
			double angle = random(0, 359);
			Double xspeed = cos(angle) * 5;
			Double yspeed = sin(angle) * 5;
			
			player.vel.x = xspeed;
			player.vel.y = yspeed;
			player.vel.z = 15 + random(-5, 5);
			
			player.A_StartSound("poot/poot", CHAN_AUTO);
		}
	}
	
	override void init()
	{
		eventname = "Farting player";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_ProjectileModifier : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_ProjectileModifier") return false;
		}
		
		return result;
	}
}

Class GZC_FastProjectiles : GZC_ProjectileModifier
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(1.5);
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bMissile) continue;
			
			let def = GetDefaultByType(mo.getClass());
			
			mo.Vel3DFromAngle(def.speed, mo.angle, mo.pitch);
		}
	}

	override void init()
	{
		eventname = "Fast projectiles";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}


Class GZC_SlowProjectiles : GZC_ProjectileModifier
{

	override void spawnFunc(Actor mo)
	{
		if (mo) mo.A_ScaleVelocity(0.5);
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bMissile) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.Vel3DFromAngle(def.speed, mo.angle, mo.pitch);
		}
	}

	override void init()
	{
		eventname = "Slow projectiles";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}

}

Class GZC_ExtraSlowProjectiles : GZC_ProjectileModifier
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.25);
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bMissile) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.Vel3DFromAngle(def.speed, mo.angle, mo.pitch);
		}
	}

	override void init()
	{
		eventname = "Slower projectiles";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}

}

Class GZC_PainfullySlowProjectiles : GZC_ProjectileModifier
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.01);
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (!mo.bMissile) continue;
			
			let def = getDefaultByType(mo.getClass());
			mo.Vel3DFromAngle(def.speed, mo.angle, mo.pitch);
		}
	}

	override void init()
	{
		eventname = "Painfully Slow projectiles";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}

}

Class GZC_ExplodingBulletPuffs : GZC_Event
{
	override void spawnFunc(Actor mo)
	{
		if (mo is "BulletPuff")
		{
			mo.A_Explode(32, 128, 0);
		}
	}

	override void init()
	{
		eventname = "All bullet puffs explode";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

Class GZC_SeekerProjectiles : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (!mo.bMissile) continue;
			
			if (!mo.target) continue;
			
			if (!(mo.target.bIsMonster || mo.target is "PlayerPawn")) continue;
			
			let def = GetDefaultByType(mo.getClass());
				
			if (def.bSeekerMissile) continue;
					
			mo.bSeekerMissile = true;
			mo.tracer = player;
			mo.A_Tracer();
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				
				mo.bSeekerMissile = false;
			}
		}
	}

	override void init()
	{
		eventname = "All projectiles seek player";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

/*
Shine on you crazy diamond.
*/

Class GZC_FakeLagCrash : GZC_Event
{
	int spawn;
	int delay;

	override void eventFunc()
	{
		if (life > delay)
		{
			string music = level.music;
			
			let player = players[consoleplayer].mo;
			player.S_ChangeMusic("");
			
							//30 Million
			for (int i = 0; i < 30000000; ++i)
			{
				let idiot = new('thinker');
				idiot.destroy();
			}
		
			player.S_ChangeMusic(music);
		
			eventname = "Fake crash";
			activated = true;
		}
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		spawn = gametic;
		delay = 35 * random(5, 10);
		eventname = "Nothing.";
		duration = 35 * 60;
		type = E_HiddenTimer;
	}
}

Class GZC_RestartLevel : GZC_Event
{
	bool restart;

	override void eventFunc()
	{
		restart = true;
		if (life == duration - 1)
		{
			int rng = random(1, 5);
			if (rng != 3)
			{
				type = E_HiddenTimer;
				life = 0;
				duration = 35 * 15;
				eventname = "Fake level restart";
				restart = false;
				activated = true;
			}
		}
	}
	
	override void closeFunc()
	{
		if (restart)
		{
			level.changeLevel(level.mapname);
		}
	}

	override void init()
	{
		eventname = "Exit and restart level";
		duration = 35 * 10;
		type = E_Timed;
	}
}