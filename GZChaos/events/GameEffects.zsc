Class GZC_ShuffleAmmoTypes : GZC_Event
{
	override void eventFunc()
	{
		Array<Class<Ammo> > types;
		
		PlayerPawn player = players[consoleplayer].mo;
		WeaponSlots weapons = players[consoleplayer].weapons;
		
		for (int slot = 0; slot < 10; ++slot)
		{
			int numWeaps = weapons.slotSize(slot);
			
			if (numWeaps == 0) continue;
			
			for (int index = 0; index < numWeaps; ++index)
			{
				Class<weapon> gun = weapons.getWeapon(slot, index);
				
				let def = getDefaultByType(gun);
				
				if (def.ammoType1) types.push(def.ammoType1);
				if (def.ammoType2) types.push(def.ammoType2);
			}
		}
		
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "weapon" && Inventory(mo).owner is "PlayerPawn")
			{
				let gun = Weapon(mo);
				
				if (gun.AmmoType1)
				{
					while (true)
					{
						let selected = types[random(0, types.size() - 1)];
						if (selected is gun.AmmoType1) continue;
						
						gun.AmmoType1 = (Class<Ammo>)(selected);
						gun.Ammo1 = Ammo(player.FindInventory(selected));
						
						break;
					}
				}
			
				if (gun.AmmoType2)
				{
					while (true)
					{
						let selected = types[random(0, types.size())];
						if (selected is gun.AmmoType2) continue;
					
						gun.AmmoType2 = (Class<Ammo>)(selected);
						gun.Ammo2 = Ammo(player.FindInventory(selected));
						break;
					}
				}
			}
		}
		
		activated = true;
	}
	
	override void closeFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "weapon" && Inventory(mo).owner is "PlayerPawn")
			{
				let gun = Weapon(mo);
				let def = getDefaultByType(gun.getClass());
				
				if (gun.ammoType1)
				{
					gun.ammoType1 = def.ammoType1;
					gun.ammo1 = Ammo(Player.findInventory(gun.ammoType1.getClassName()));
				}
				
				if (gun.ammoType2)
				{
					gun.ammoType2 = def.ammoType2;
					gun.ammo2 = Ammo(Player.findInventory(gun.ammoType2.getClassName()));
				}
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_ShuffleAmmoTypes');
		event.eventname = "Shuffled ammo pool";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_LimpProjectiles : GZC_Event
{
	override void spawnFunc(Actor mo)
	{
		if (mo.bMissile)
		{
			if (!(mo.target is "PlayerPawn"))
			{
				mo.bNoGravity = false;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_LimpProjectiles');
		event.eventname = "Limp enemy projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_JupiterGravity : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_MoonGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(10);
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_JupiterGravity');
		event.eventname = "Jupiter Gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_MoonGravity : GZC_Event
{
	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_JupiterGravity") return false;
		}
		
		return result;
	}

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_LowGravity();
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_MoonGravity');
		event.eventname = "Moon Gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FartingMonsters : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo.bIsMonster && mo.health > 0)
			{
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % (35 * 2) == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FartingMonsters');
		event.eventname = "Farting Monsters";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FartingItems : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		while (mo = Actor(it.next()))
		{
			if (mo is "inventory")
			{
				if (Inventory(mo).owner) continue;
				double zfloor = mo.getZAt();
				if (zfloor != mo.pos.z) continue;
				if ((gametic + random(0, 35)) % (35 * 2) == 0)
				{
					if (!random(0, 5)) continue;
				
					double angle = random(0, 359);
					Double xspeed = cos(angle) * 5;
					Double yspeed = sin(angle) * 5;
					
					mo.vel.x = xspeed;
					mo.vel.y = yspeed;
					mo.vel.z = 15 + random(-5, 5);
					
					mo.A_StartSound("poot/poot", CHAN_AUTO);
				}
			}
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FartingItems');
		event.eventname = "Farting items";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FartingPlayer : GZC_Event
{
	override void eventFunc()
	{
		PlayerPawn player = players[consoleplayer].mo;
		
		double zfloor = player.getZAt();
		if (zfloor != player.pos.z) return;
		if ((gametic + random(0, 35)) % (35 * 2) == 0)
		{
			if (!random(0, 5)) return;
		
			double angle = random(0, 359);
			Double xspeed = cos(angle) * 5;
			Double yspeed = sin(angle) * 5;
			
			player.vel.x = xspeed;
			player.vel.y = yspeed;
			player.vel.z = 15 + random(-5, 5);
			
			player.A_StartSound("poot/poot", CHAN_AUTO);
		}
	}
	
	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FartingPlayer');
		event.eventname = "Farting player";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_FastProjectiles : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(1.5);
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FastProjectiles');
		event.eventname = "Fast projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}


Class GZC_SlowProjectiles : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.5);
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_SlowProjectiles');
		event.eventname = "Slow projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class GZC_ExtraSlowProjectiles : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.25);
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_ExtraSlowProjectiles');
		event.eventname = "Slower projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class GZC_PainfullySlowProjectiles : GZC_Event
{

	override void spawnFunc(Actor mo)
	{
		mo.A_ScaleVelocity(0.01);
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_PainfullySlowProjectiles');
		event.eventname = "Painfully Slow projectiles";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}

}

Class GZC_DisableGravity : GZC_Event
{
	bool set;
	
	Array<Actor> flying;

	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerInfo infoplayer = players[consoleplayer];
		PlayerPawn player = infoplayer.mo;
		
		infoplayer.cheats |= CF_FLY;
		player.bFly = true;
		
		while (mo = Actor(it.next()))
		{
			if (!(mo is "playerPawn")) mo.A_SetGravity(0.0);
			if (!set) {
				mo.vel.z = FRandom(0.1, 0.9);
				if (mo.bIsMonster)
				{
					if (mo.bFloat) mo.giveInventory('GZC_CanAlreadyFly', 1);
					mo.bFloat = true;
					mo.bNoGravity = true;
				}
			}
		}
		
		set = true;
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.create("Actor");
		Actor mo;
		
		PlayerInfo infoplayer = players[consoleplayer];
		PlayerPawn player = infoplayer.mo;
		
		infoplayer.cheats &= ~(CF_FLY);
		player.bFly = false;
		
		while (mo = Actor(it.next()))
		{
			mo.A_SetGravity(1);
			if (!mo.countInv('GZC_CanAlreadyFly'))
			{
				mo.bFloat = false;
				mo.bNoGravity = false;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_DisableGravity');
		event.eventname = "Everything ignores gravity";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_CanAlreadyFly : Inventory {}

Class GZC_ExplodingBulletPuffs : GZC_Event
{
	override void spawnFunc(Actor mo)
	{
		if (mo is "BulletPuff")
		{
			mo.A_Explode(32, 128, 0);
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_ExplodingBulletPuffs');
		event.eventname = "All bullet puffs explode";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_SeekerProjectiles : GZC_Event
{
	override void eventFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		PlayerPawn player = players[consoleplayer].mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				mo.bSeekerMissile = true;
				mo.tracer = player;
				mo.A_Tracer();
			}
		}
	}
	
	override void closeFunc()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo.bMissile)
			{
				
				mo.bSeekerMissile = false;
			}
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_SeekerProjectiles');
		event.eventname = "All projectiles seek player";
		event.duration = 35 * 60 * 3;
		event.type = E_Timed;
		return event;
	}
}

Class GZC_OUCH : GZC_EVENT
{
	bool set;
	
	override bool verify()
	{
		if (random(0, 10))
		{
			return false;
		}
	
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_SetAllWallsToStartan") return false;
			if (event is "GZC_SetAllWallsToFireblu") return false;
		}
		
		return result;
	}

	//This code is borrowed from Marisa Kirasame's OUCH_M mod, used with permission
	override void eventFunc()
	{
		if (!set)
		{
			int i;
			TextureID thetex;
			Line l;
			Sector s;
			thetex = TexMan.CheckForTexture("STFOUCH0",TexMan.Type_Any);
			if ( thetex.IsNull() || !thetex.IsValid() ) return; // no texture available
			int j, k;
			for ( i=0; i<level.Lines.Size(); i++ )
			{
				l = level.Lines[i];
				for ( j=0; j<3; j++ ) for ( k=0; k<2; k++ ) if ( l.sidedef[k] && !l.sidedef[k].GetTexture(j).IsNull() && (l.sidedef[k].GetTexture(j) != skyflatnum) ) l.sidedef[k].SetTexture(j,thetex);
			}
			for ( i=0; i<level.Sectors.Size(); i++ )
			{
				s = level.Sectors[i];
				for ( j=0; j<2; j++ ) if ( !level.Sectors[i].GetTexture(j).IsNull() && (level.Sectors[i].GetTexture(j) != skyflatnum) ) level.Sectors[i].SetTexture(j,thetex);
				s.flags |= Sector.SECF_FRICTION;
			}
			thetex = TexMan.CheckForTexture("OUCHSKY",TexMan.Type_Any);
			level.ChangeSky(thetex,thetex);
			set = true;
		}
	
		Line l;
		Sector s;
		int i, j;
		for ( i=0; i<level.Lines.Size(); i++ )
		{
			l = level.Lines[i];
			for ( j=0; j<3; j++ )
			{
				l.sidedef[0].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
				l.sidedef[0].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
				l.sidedef[0].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				if ( level.Lines[i].sidedef[1] )
				{
					l.sidedef[1].SetTextureXOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureYOffset(j,FRandom[Ouch](-256.0,256.0));
					l.sidedef[1].SetTextureXScale(j,FRandom[Ouch](-4.0,4.0));
					l.sidedef[1].SetTextureYScale(j,FRandom[Ouch](-4.0,4.0));
				}
			}
		}
		int echochance = Random[Ouch](0,10);
		for ( i=0; i<level.Sectors.Size(); i++ )
		{
			s = level.Sectors[i];
			for ( j=0; j<2; j++ )
			{
				s.SetXOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetYOffset(j,FRandom[Ouch](-256.0,256.0));
				s.SetXScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetYScale(j,FRandom[Ouch](-4.0,4.0));
				s.SetAngle(j,FRandom[Ouch](0.0,360.0));
				s.SetColor(Color(Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255),Random[Ouch](160,255)),0);
			}
			if ( gametic % 3 ) continue;
			if ( echochance < 3 ) s.SetEnvironmentID(65535);
			else s.SetEnvironmentID(0);
			s.friction = FRandom[Ouch](0.9,1.1);
		}
		
		ThinkerIterator aa = ThinkerIterator.Create("Actor");
		Actor a;
		while ( a = Actor(aa.Next()) )
		{
			if ( a.sprite == a.GetSpriteIndex('OUCH') ) continue; // abort_m ouch faces are unaffected by this
			if ( a is "OuchMFace" ) continue; // ouch faces do their own thing
			if ( !(gametic%3) && (Random[Ouch](0,10) < 3)) a.A_StartSound("ouch/dspdiehi",CHAN_5, 0, FRandom[Ouch](0.05,0.3));
			if ( a.player && (!a.player.ReadyWeapon || (a.player.ReadyWeapon.GetClassName() != "OuchWeapon")) ) // ouch weapon is unaffected too
			{
				for ( PSprite psp=a.player.psprites; psp; psp=psp.next )
				{
					if ( psp.sprite == a.GetSpriteIndex('TNT1') ) continue;
					psp.sprite = a.GetSpriteIndex('OUCF');
					psp.frame = 1;
				}
			}
			if ( a.sprite != a.GetSpriteIndex('TNT1') )
			{
				Vector2 base = (1.0,1.0);

				// view-dependant, but who cares, it shouldn't desync
				base = TexMan.GetScaledSize(a.CurState.GetSpriteTexture(int(a.spriteRotation)));
				base.x /= 24.0;
				base.y /= 31.0;
				Vector2 defscale = GetDefaultByType(a.GetClass()).scale;
				base.x *= defscale.x;
				base.y *= defscale.y;
				a.sprite = a.GetSpriteIndex('OUCF');
				a.frame = 0;
				// helpers so you can tell what is what
				if ( a.bISMONSTER ) a.A_SetTranslation('OuchEnemy');
				else if ( a is 'RedCard' || a is 'RedSkull' ) a.A_SetTranslation('OuchRedKey');
				else if ( a is 'BlueCard' || a is 'BlueSkull' ) a.A_SetTranslation('OuchBlueKey');
				else if ( a is 'YellowCard' || a is 'YellowSkull' ) a.A_SetTranslation('OuchYellowKey');
				else if ( a is 'Ammo' || a is 'Weapon' ) a.A_SetTranslation('OuchAmmo');
				else if ( a is 'Health' ) a.A_SetTranslation('OuchHealth');
				else if ( a is 'Armor' ) a.A_SetTranslation('OuchArmor');
				else if ( a is 'Inventory' ) a.A_SetTranslation('OuchMiscItem');
				else a.A_SetTranslation('OuchOther');
				
				a.A_SetScale(base.x*FRandom[Ouch](0.8,1.2),base.y*FRandom[Ouch](0.8,1.2));
			}
			if ( (a.sprite == a.GetSpriteIndex('TNT1')) || a.bNOSECTOR || a.bNOCLIP || a.bINVISIBLE ) continue; // prevent breakage of some things
			if (!(a is "PlayerPawn"))
			{
				if ( !(gametic%10)) a.A_ChangeVelocity(a.vel.x+FRandom[Ouch](-1.0,1.0),a.vel.y+FRandom[Ouch](-1.0,1.0),a.vel.z+FRandom[Ouch](-10.0,10.0));
			}
		}
	}
	
	override void closeFunc()
	{
	
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_OUCH');
		event.eventname = "OUCH";
		event.duration = 35 * 60 * 9999;
		event.type = E_PerLevel;
		event.deleteme = true;
		return event;
	}
}

Class GZC_FakeLagCrash : GZC_Event
{
	int spawn;
	int delay;

	override void eventFunc()
	{
		if (life > delay)
		{
			string music = level.music;
			
			let player = players[consoleplayer].mo;
			player.S_ChangeMusic("");
			
							//30 Million
			for (int i = 0; i < 30000000; ++i)
			{
				let idiot = new('thinker');
				idiot.destroy();
			}
		
			player.S_ChangeMusic(music);
		
			eventname = "Fake crash";
			activated = true;
		}
	}
	
	override void closeFunc()
	{
	
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_FakeLagCrash');
		GZC_FakeLagCrash(event).spawn = gametic;
		GZC_FakeLagCrash(event).delay = 35 * random(5, 10);
		event.eventname = "Nothing.";
		event.duration = 35 * 60;
		event.type = E_HiddenTimer;
		return event;
	}
}

Class GZC_RestartLevel : GZC_Event
{
	bool restart;

	override void eventFunc()
	{
		restart = true;
		if (life == duration - 1)
		{
			int rng = random(1, 5);
			if (rng != 3)
			{
				type = E_HiddenTimer;
				life = 0;
				duration = 35 * 15;
				eventname = "Fake level restart";
				restart = false;
				activated = true;
			}
		}
	}
	
	override void closeFunc()
	{
		if (restart)
		{
			level.changeLevel(level.mapname);
		}
	}

	Static GZC_Event create()
	{
		GZC_Event event = new('GZC_RestartLevel');
		event.eventname = "Exit and restart level";
		event.duration = 35 * 10;
		event.type = E_Timed;
		return event;
	}
}