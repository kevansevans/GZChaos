Class GZC_TextureSwapEffect : GZC_Event
{
	Array<String> oldnames;
	Array<Int> oldlights;
	TextureID oldskyA;
	TextureID oldskyB;

	override bool verify()
	{
		bool result = Super.verify();
	
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is "GZC_TextureSwapEffect") return false;
		}
		
		return result;
	}
	
	void initialize()
	{
		oldnames.clear();
		oldlights.clear();
	
		oldskyA = level.SkyTexture1;
		oldskyB = level.SkyTexture2;
	}
	
	override void closeFunc()
	{
		resetMap();
	}
	
	void resetMap()
	{
		level.ChangeSky(oldSkyA, oldSkyB);
	
		int texTracker;
		
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, TexMan.checkForTexture(oldnames[texTracker]));
					++texTracker;
				}
			}
		}
		
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				level.sectors[se].setTexture(0, TexMan.checkForTexture(oldnames[texTracker]));
				++texTracker;
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				level.sectors[se].setTexture(1, TexMan.checkForTexture(oldnames[texTracker]));
				++texTracker;
			}
			level.sectors[se].lightlevel = oldlights[se];
		}
	}
}

Class GZC_SetAllWallsToStartan : GZC_TextureSwapEffect
{
	Array<Int> flags;

	override void eventFunc()
	{
		initialize();
		
		flags.clear();
	
		TextureID walltex = TexMan.checkForTexture("STARTAN2");
	
		level.ChangeSky(TexMan.checkForTexture("SKY1"), TexMan.checkForTexture(''));
	
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
			
			flags.push(sidedef.linedef.flags);
			sidedef.linedef.flags &= ~(Line.ML_DONTPEGTOP | Line.ML_DONTPEGBOTTOM);
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID curtex = sidedef.GetTexture(wall);
				if (curtex)
				{
					string wallname = TexMan.getName(curtex);
					
					if (wallname != "DOORTRAK" && !checkIfReplaceable(wallname)) continue;
					sidedef.setTexture(wall, walltex);
					oldnames.push(TexMan.getName(wallTex));
				}
			}
		}
		
		TextureID floortex = TexMan.CheckForTexture("FLOOR0_1");
		TextureID ceiltex = TexMan.CheckForTexture("CEIL1_1");
		
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			string orgFloorText = TexMan.getName(level.sectors[se].getTexture(0));
			if (orgFloorText != "F_SKY1" && checkIfReplaceable(orgFloorText))
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(0)));
				level.sectors[se].setTexture(0, floortex);
			}
			string orgCeilText = TexMan.getName(level.sectors[se].getTexture(1));
			if (orgCeilText != "F_SKY1" && checkIfReplaceable(orgCeilText))
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(1)));
				level.sectors[se].setTexture(1, ceiltex);
			}
			oldlights.push(level.sectors[se].lightlevel);
			level.sectors[se].lightlevel = 192;
		}
		activated = true;
	}
	
	override void closeFunc()
	{
		super.closeFunc();
		
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
			sidedef.linedef.flags = flags[si];
		}
	}
	
	override void init()
	{
		eventname = "MyFirstMap.wad";
		duration = 35 * 60 * 5;
		deleteme = true;
		type = E_Timed;
	}
}

Class GZC_SetAllWallsToFireblu : GZC_TextureSwapEffect
{
	override void eventFunc()
	{
		initialize();
	
		TextureID newtex = TexMan.checkForTexture("FIREBLU1");
		
		level.ChangeSky(newtex, TexMan.checkForTexture(''));
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, newtex);
					oldnames.push(TexMan.getName(wallTex));
				}
			}
		}
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(0)));
				level.sectors[se].setTexture(0, newtex);
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(1)));
				level.sectors[se].setTexture(1, newtex);
			}
			oldlights.push(level.sectors[se].lightlevel);
			level.sectors[se].lightlevel = 192;
		}
		
		activated = true;
	}
	
	override void init()
	{
		eventname = "Everyone's favorite texture";
		duration = 35 * 60 * 5;
		deleteme = true;
		type = E_Timed;
	}
}

Class GZC_SetAllWallsToAlpha : GZC_TextureSwapEffect
{
	override void eventFunc()
	{
		initialize();
	
		TextureID jule = TexMan.checkForTexture("JULESUCK");
		TextureID tom = TexMan.checkForTexture("TOMKING");
		
		level.ChangeSky(jule, TexMan.checkForTexture(''));
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, jule);
					oldnames.push(TexMan.getName(wallTex));
				}
			}
		}
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(0)));
				level.sectors[se].setTexture(0, tom);
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(1)));
				level.sectors[se].setTexture(1, tom);
			}
			oldlights.push(level.sectors[se].lightlevel);
			level.sectors[se].lightlevel = 192;
		}
		
		activated = true;
	}

	override void init()
	{
		eventname = "Doom Alpha 0.2";
		duration = 35 * 60 * 5;
		deleteme = true;
		type = E_Timed;
	}
}

Class GZC_SetAllWallsToISuck : GZC_TextureSwapEffect
{

	override void eventFunc()
	{
		initialize();
	
		TextureID newtex = TexMan.checkForTexture("ISUCK");
		
		level.ChangeSky(newtex, TexMan.checkForTexture(''));
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, newtex);
					oldnames.push(TexMan.getName(wallTex));
				}
			}
		}
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(0)));
				level.sectors[se].setTexture(0, newtex);
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(1)));
				level.sectors[se].setTexture(1, newtex);
			}
			oldlights.push(level.sectors[se].lightlevel);
			level.sectors[se].lightlevel = 192;
		}
		
		activated = true;
	}

	override void init()
	{
		eventname = "I suck at making maps";
		duration = 35 * 60 * 5;
		deleteme = true;
		type = E_Timed;
	}
}

Class GZC_SetAllWallsToNoFlat : GZC_TextureSwapEffect
{

	override void eventFunc()
	{
		initialize();
	
		TextureID newtex = TexMan.checkForTexture("-noflat-");
		
		level.ChangeSky(newtex, TexMan.checkForTexture(''));
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
		
			for (int wall = 0; wall < 3; ++wall)
			{
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					if (!checkIfReplaceable(TexMan.getName(walltex))) continue;
					sidedef.setTexture(wall, newtex);
					oldnames.push(TexMan.getName(wallTex));
				}
			}
		}
		for (int se = 0; se < level.sectors.size(); ++se)
		{
			if (TexMan.getName(level.sectors[se].getTexture(0)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(0)));
				level.sectors[se].setTexture(0, newtex);
			}
			if (TexMan.getName(level.sectors[se].getTexture(1)) != "F_SKY1")
			{
				oldnames.push(TexMan.getName(level.sectors[se].getTexture(1)));
				level.sectors[se].setTexture(1, newtex);
			}
			oldlights.push(level.sectors[se].lightlevel);
			level.sectors[se].lightlevel = 192;
		}
		
		activated = true;
	}

	override void init()
	{
		eventname = "Testing... 1, 2, 3, testing...";
		duration = 35 * 60 * 5;
		deleteme = true;
		type = E_Timed;
	}
}

Class GZC_DiscoSkybox : GZC_Event
{
	TextureID oldskyA;
	TextureID oldskyB;
	
	Array<String> textures;
	int interval;
	override void eventFunc()
	{
		if (!oldskyA) {
		
			oldskyA = level.skytexture1;
			oldskyB = level.skytexture2;
			textures.clear();
			
			interval = random(1, 10);
		
			for (int i = 0; i < Wads.getNumLumps(); ++i)
			{
				TextureID _locTexture = TexMan.checkForTexture(Wads.getLumpName(i));
				String texturename = TexMan.getName(_locTexture);
				
				if (texturename)
				{
					textures.push(texturename);
				}
			}
		}
		
		if (gametic % interval == 0)
		{
			interval = random(1, 10);
			int index = random(0, textures.size() - 1);
			level.changeSky(TexMan.checkForTexture(textures[index]), TexMan.checkForTexture(''));
		}
	}
	
	override void closeFunc()
	{
		level.changeSky(oldSkyA, oldSkyB);
	}
	
	override void init()
	{
		eventname = "Disco Skybox";
		duration = 35 * 60;
		type = E_Timed;
	}
}

Class GZC_SuperSecretsEverywhere : GZC_Event
{
	override void eventFunc()
	{
		for (int i = 0; i < level.sectors.size(); ++i)
		{
			sector sec = level.sectors[i];
			sec.flags |= Sector.SECF_SECRET;
		}
		
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		
		while ((mo = Actor(it.Next ())))
		{
			if (mo is "Inventory")
			{
				mo.bCountSecret = true;
			}
			
		}
	}
	
	override void closeFunc()
	{}
	
	override void init()
	{
		eventname = "Everything is a secret";
		duration = 35 * 60;
		type = E_Instant;
	}
}

Class GZC_IncreasedSectorFriction : GZC_Event
{
	Array<Sector> applied;
	int factor;
	
	override void eventFunc()
	{
		if (!applied.size()) 
		{
			applied.clear();
			factor = random(2, 10);
			eventname = factor .. "x sector friction";
		}
		
		for (int i = 0; i < level.sectors.size(); ++i)
		{
			sector sec = level.sectors[i];
			
			if (applied.size() == 0 || applied.find(sec) == applied.size())
			{
				sec.friction /= factor;
				sec.flags |= Sector.SECF_FRICTION;
				applied.push(sec);
			}
		}
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < applied.size(); ++i)
		{
			if (!applied[i]) continue;
			
			sector sec = applied[i];
			
			sec.friction *= factor;
			sec.flags &= ~(Sector.SECF_FRICTION);
		}
	}
	
	override void init()
	{
		eventname = "Increased Sector Friction";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}

/*Class GZC_TheVomitorium : GZC_Event
{
	Array<line> lines;

	override void eventFunc()
	{
		lines.clear();
		
		PlayerPawn player = players[consoleplayer].mo;
		
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			
			if (linedef.special != 0)
			{
				lines.push(linedef);
				continue;
			}
			
			scroll_wall(0, random(-16,16),random(-16,16),0,7);
			
		}
		
		activated = true;
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			if (lines.find(linedef) != lines.size())
			{
				linedef.special = 0;
				linedef.args[0] = 0;
				linedef.args[1] = 0;
				linedef.args[2] = 0;
				linedef.args[3] = 0;
				linedef.args[4] = 0;
			}
		}
	}
	
	override void init()
	{
		GZC_Event event = new('GZC_TheVomitorium');
		eventname = "The Vomitorium";
		duration = 35 * 60;
		type = E_Timed;
	}
}*/

Class GZC_ClearAutoMap : GZC_Event
{
	override void eventFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			level.lines[i].flags &= ~(Line.ML_MAPPED);
		}
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		eventname = "Clear Auto Map";
		duration = 35 * 30;
		type = E_Instant;
	}
}

/*Class GZC_BrokenBSPRendering : GZC_Event
{
	Array<line> lines;

	override void eventFunc()
	{
		
		if (!lines.size())
		{
			lines.clear();
			for (int i = 0; i < level.lines.size(); ++i)
			{
				line linedef = level.lines[i];
				if (linedef.flags & line.ML_TWOSIDED)
				{
					linedef.flags &= ~(line.ML_TWOSIDED);
					continue;
				}
				else lines.push(linedef);
			}
		}
	}
	
	override void closeFunc()
	{
		for (int i = 0; i < level.lines.size(); ++i)
		{
			line linedef = level.lines[i];
			if (lines.find(linedef) == lines.size())
			{
				linedef.flags |= line.ML_TWOSIDED;
			}
		}
	}
	
	override void init()
	{
		eventname = "BSP Corruption";
		duration = 35 * 60 * 3;
		type = E_Timed;
	}
}*/

Class GZC_TheFloorIsLava : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("LAVA1"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 20;
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		eventname = "The floor is lava!";
		duration = 35 * 10;
		type = E_Instant;
	}
}

Class GZC_TheFloorIsNukage : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("NUKAGE1"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 10;
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		eventname = "The floor is Nukage!";
		duration = 35 * 10;
		type = E_Instant;
	}
}

Class GZC_TheFloorIsSludge : GZC_Event
{
	override void eventFunc()
	{
		let player = players[consoleplayer].mo;
		player.cursector.setTexture(0, TexMan.CheckForTexture("SLIME01"));
		player.cursector.damageType = 'slime';
		player.cursector.damageinterval = 35;
		player.cursector.damageamount = 5;
	}
	
	override void closeFunc()
	{
	
	}
	
	override void init()
	{
		eventname = "The floor is sludge!";
		duration = 35 * 10;
		type = E_Instant;
	}
}

Class GZC_ShuffleKeyTextures : GZC_Event
{
	override void eventFunc()
	{
		for (int si = 0; si < level.sides.size(); ++si)
		{
			side sidedef = level.sides[si];
	
			for (int wall = 0; wall < 3; ++wall)
			{
				int rng = random(0, 1);
				if (rng == 1) continue;
				TextureID walltex = sidedef.GetTexture(wall);
				if (walltex)
				{
					string texname = TexMan.getName(walltex);
					texname.truncate(4);
					if (texname != "DOOR") continue;
					else
					{
						switch (name(TexMan.getName(walltex)))
						{
							case 'DOORBLU':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORRED2'));
								if (random(1, 10) != 10) break;
							case 'DOORRED2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORYEL'));
								if (random(1, 10) != 10) break;
							case 'DOORYEL':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORBLU2'));
								if (random(1, 10) != 10) break;
							case 'DOORBLU2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORRED'));
								if (random(1, 10) != 10) break;
							case 'DOORRED':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORYEL2'));
								if (random(1, 10) != 10) break;
							case 'DOORYEL2':
								sidedef.setTexture(wall, TexMan.checkForTexture('DOORBLU'));
								break;
						}
					}
				}
			}
		}
	}
	
	override void closeFunc()
	{
	
	}

	override void init()
	{
		eventname = "Shuffle key color textures";
		duration = 35 * 5;
		type = E_Timed;
	}
}

Class GZC_MisalignAllTextures : GZC_Event
{
	override void eventFunc()
	{
		int odds = random(1, 10);
		double amount = (double(odds) / 10) * 100;
		eventname = "I forgot to align " .. int(amount) .. "% of my textures";
		
		for (int i = 0; i < level.sides.size(); ++i)
		{
			int rng = random(1, 10);
			if (rng > odds) continue;
			side sidedef = level.sides[i];
			
			for (int j = 0; j < 3; ++j)
			{
				if (sidedef.getTexture(j))
				{
					double x = sidedef.getTextureXOffset(j);
					double y = sidedef.getTextureXOffset(j);
					sidedef.setTextureXOffset(j, x + random(-4, 4));
					sidedef.setTextureYOffset(j, y + random(-4, 4));
				}
			}
		}
		activated = true;
	}
	
	override void closeFunc() {}
	
	override void init()
	{
		eventname = "Misalign textures";
		duration = 35 * 30;
		type = E_PerLevel;
	}
}