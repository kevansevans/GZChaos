Class GZC_EventList play
{
	Array<String> events;
	Array<int> rolls;
	
	GZC_SeededRNG rng;

	static GZC_EventList create()
	{
		GZC_EventList list = new('GZC_EventList');
		
		list.rng = new('GZC_SeededRNG');
		list.rng.init();
		
		list.timemodifier = 1.0;
		list.cachedEffects.clear();
		
		list.events.clear();
		list.rolls.clear();
		
		Array<String> cleaners;
		cleaners.clear();
		
		for (int i = 0; i < AllClasses.size(); ++i)
		{
			if (!(AllClasses[i] is "GZC_Event")) continue;
			
			let event = GZC_Event(new(AllClasses[i]));
			event.init();
			if (event.skipme) continue;
			
			list.events.push('' .. AllClasses[i].getClassName());
		}
		
		return list;
	}
	
	int rngcounter;
	int modifier;
	
	bool debug;
	double timemodifier;
	
	EffectInventory effects;
	
	int timeLimit()
	{
		int base = 35 * (min(max(Cvar.getCvar("GZC_TimerDuration").getInt() + modifier, 20), 60));
		
		PlayerPawn player = players[consoleplayer].mo;
		
		base = int(base * timemodifier);
	
		return int(max(5, base));
	}
	
	Array<String> cachedEffects;
	
	bool set;
	
	GZC_Event getEffect(int _ignore = -1)
	{
		PlayerPawn player = players[consoleplayer].mo;
		effects = EffectInventory(player.findInventory("EffectInventory"));
		
		GZC_Event selectedevent;
		bool restart;
		
		while (true)
		{
			int roll = rng.getValue();
			rngcounter += roll;
			rngcounter = rngcounter % events.size();
			
			if (rngcounter == _ignore) continue;
			
			if (rolls.find(rngcounter) != rolls.size()) continue;
			
			let _event = new(events[rngcounter]);
			selectedevent = GZC_Event(_event);
			
			selectedevent.init();
			
			if (!selectedEvent.verify()) continue;
			if (rng.getValue() < selectedevent.weight) continue;
			
			double limiter = Cvar.getCvar("GZC_MaxEffectDuration").getFloat();
			if (limiter != 0)
			{
				int value = int(35 * 60 * limiter);
				selectedEvent.duration = min(value, selectedEvent.duration);
			}
			
			selectedevent.duration += 35 * random(Cvar.getCvar("GZC_MinTimeFlux").getInt() * -1, Cvar.getCvar("GZC_MaxTimeFlux").getInt());
			
			String classname = selectedevent.getClassName();
			if (cachedEffects.find(classname) != cachedEffects.size()) continue;
			
			rolls.insert(0, rngcounter);
			rolls.resize(Cvar.getCvar("GZC_MemoryBuffer").getInt());
			
			break;
		}
		
		String classname = selectedevent.getClassName();
		cachedEffects.push(classname);
		cachedEffects.resize(Cvar.getCvar("GZC_MemoryBuffer").getInt());
		
		if (!selectedevent) return GZC_Event(new('GZC_DoNothing'));
		else return selectedevent;
	}
}

Class GZC_SeededRNG play
{
	int table[256];
	Array<Int> pool;
	int r_index;
	Transient Cvar seed;
	
	bool amSeeded;
	
	void init()
	{
		pool.clear();
		amSeeded = Cvar.getCvar('GZC_UseSeed', players[consoleplayer]).getBool();
		seed = Cvar.getCvar('GZC_SeedValue', players[consoleplayer]);
	
		for (int i = 0; i < 256; ++i)
		{
			table[i] = i + 1;
		}
		
		if (!seed) setRandomSeed();
		if (!amSeeded || seed.getString() == "") setRandomSeed();
		
		string input = seed.getString();
		int loops;
		while(pool.size() < 256)
		{
			fillPool(input, loops);
			++loops;
		}
	}
	
	void setRandomSeed()
	{
		String hextable[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
		int halfbyte = 0x0F;
		int upper = random(0, 0x7FFFFFFF);
		int lower = random(0, 0x7FFFFFFF);
		string result = "";
		
		while (upper > 0)
		{
			result = hextable[upper & halfbyte] .. result;
			upper = upper >> 4;
		}
		
		while (lower > 0)
		{
			result = result .. hextable[lower & halfbyte];
			lower = lower >> 4;
		}
		
		seed.setString(result);
	}
	
	void fillPool(String _input, Int _offset)
	{
		int charindex = 0;
		int indexvalue;
		while (charIndex <= _input.length())
		{
			int code = (_input.mid(charIndex, 2).toInt(10) + _offset) % 256;
			pool.push(table[code]);
			++charIndex;
		}
	}
	
	int getValue()
	{
		if (!Cvar.getCvar('GZC_UseSeed').getBool())return random(1, 0xFFFF);
		
		int value = pool[r_index];
		++r_index;
		if (r_index >= pool.size()) r_index = 0;
		
		return value;
	}
}

enum E_GameType
{
	GAME_Any	 = 0,
	GAME_Doom	 = 1,
	GAME_Heretic = 2,
	GAME_Hexen	 = 4,
	GAME_Strife	 = 8,
	GAME_Chex	 = 16,

	GAME_Raven			= GAME_Heretic|GAME_Hexen,
	GAME_DoomChex		= GAME_Doom|GAME_Chex,
	GAME_DoomStrifeChex	= GAME_Doom|GAME_Strife|GAME_Chex
}

enum E_EventType
{
	E_Instant,
	E_Timed,
	E_PerLevel,
	E_HiddenTimer,
	E_Permnanent
}

Class GZC_Event play
{
	Transient ThinkerIterator it;

	String eventname;
	Int duration;
	Int life;
	int weight;
	
	Bool activated;
	Bool deleteme;
	Bool skipme;
	Bool deadEffect;
	
	E_EventType type;
	
	virtual void init() 
	{
		skipme = true;
	}
	virtual void eventFunc(){}
	virtual void closeFunc(){}
	virtual void spawnFunc(Actor mo){}
	virtual void deathFunc(Actor mo){}
	virtual void damageFunc(WorldEvent event){}
	virtual void lineDamageFunc(WorldEvent event) {}
	virtual void preActivateLine(WorldEvent event) {}
	virtual void loadFunc() {}
	
	virtual void morphActor(Actor mo, Class<Actor> type)
	{
		bool ambush = mo.bAmbush;
		bool hasTarget = mo.target == null;
	
		mo.bDontMorph = false;
		mo.A_Morph(type, self.duration - self.life);
		mo.bAmbush = ambush;
		if (!hasTarget) mo.A_ClearTarget();
	}
	
	//Prevents same effects from stacking, and can be used to prevent certain
	//effects from creating bad combinations.
	virtual bool verify()
	{
		PlayerPawn player = players[consoleplayer].mo;
		EffectInventory effects = EffectInventory(player.findInventory("EffectInventory"));
		
		for (int i = 0; i < effects.events.size(); ++i)
		{
			GZC_Event event = effects.events[i];
			if (event is self.getClassName()) return false;
		}
		
		return true;
	}
	
	void givePlayerItem(string _item)
	{
		let player = players[consoleplayer].mo;
		let item = Actor.spawn(_item);
		item.touch(player);
	}
	
	void giveAndSwitchTo(string _weapon)
	{
		let player = players[consoleplayer].mo;
		if (!player.countInv(_weapon))
		{
			let item = Actor.spawn(_weapon);
			item.touch(player);
		}
		player.A_SelectWeapon(_weapon);
	}
	
	bool checkIfReplaceable(String _textureName)
	{
		string texname = _texturename;
		switch (name(texname))
		{
			case 'BIGDOOR1':
			case 'BIGDOOR2':
			case 'BIGDOOR3':
			case 'BIGDOOR4':
			case 'BIGDOOR6':
			case 'BIGDOOR7':
			case 'DOOR1':
			case 'DOOR3':
			case 'DOORBLU':
			case 'DOORBLU2':
			case 'DOORRED':
			case 'DOORRED2':
			case 'DOORTRAK':
			case 'DOORYEL':
			case 'DOORYEL2':
			case 'EXITDOOR':
			case 'SPCDOOR1':
			case 'SPCDOOR2':
			case 'SPCDOOR3':
			case 'SPCDOOR4':
			case 'TEKBRON1':
			case 'TEKBRON2':
			case 'GATE1':
			case 'GATE2':
			case 'GATE3':
			case 'GATE4':
				return false;
		}
		
		texname.truncate(2);
		if (texname == "SW") return false;
		
		return true;
	}
	
	static clearscope GZC_EventHandler fetch()
	{
		return GZC_EventHandler(StaticEventHandler.find("GZC_EventHandler"));
	}
}

Class GZC_SeedInfo : GZC_Event
{
	override void init()
	{
		skipme = true;
		eventname = "Seed: " .. Cvar.getCvar('GZC_SeedValue').getString();
		duration = 35 * 10;
		type = E_Instant;
	}
}